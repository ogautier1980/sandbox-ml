\documentclass[11pt,a4paper]{article}

% Packages essentiels
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
%\usepackage{lmodern}  % Package non disponible dans le container
\usepackage{geometry}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{tikz}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage[most]{tcolorbox}
\usepackage{enumitem}

% Configuration
\geometry{margin=2.5cm}
\usetikzlibrary{shapes,arrows,positioning,calc}

% Définitions de couleurs
\definecolor{defcolor}{RGB}{0,102,204}
\definecolor{thmcolor}{RGB}{204,0,102}
\definecolor{excolor}{RGB}{0,153,76}
\definecolor{codebackground}{RGB}{245,245,245}

% Environnements théorèmes
\newtheorem{definition}{Définition}[section]
\newtheorem{theorem}{Théorème}[section]
\newtheorem{lemma}[theorem]{Lemme}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollaire}
\newtheorem{example}{Exemple}[section]
\newtheorem{remark}{Remarque}[section]

% Boîtes personnalisées (breakable pour éviter les pages blanches)
\newtcolorbox{defbox}{breakable,colback=defcolor!5!white,colframe=defcolor!75!black,title=Définition}
\newtcolorbox{thmbox}{breakable,colback=thmcolor!5!white,colframe=thmcolor!75!black,title=Théorème}
\newtcolorbox{exbox}{breakable,colback=excolor!5!white,colframe=excolor!75!black,title=Exemple}
\newtcolorbox{warnbox}{breakable,colback=red!5!white,colframe=red!75!black,title=Avertissement}

% Commandes mathématiques
\newcommand{\C}{\mathcal{C}}
\newcommand{\K}{\mathcal{K}}
\newcommand{\M}{\mathcal{M}}
\newcommand{\A}{\mathcal{A}}
\newcommand{\Enc}{\textsf{Enc}}
\newcommand{\Dec}{\textsf{Dec}}
\newcommand{\Gen}{\textsf{Gen}}
\newcommand{\Adv}{\textsf{Adv}}
\newcommand{\xor}{\oplus}
\newcommand{\bits}{\{0,1\}}

% Configuration hyperref
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    urlcolor=blue,
    citecolor=blue
}

% Configuration listings
\lstset{
    language=Python,
    basicstyle=\ttfamily\small,
    backgroundcolor=\color{codebackground},
    frame=single,
    numbers=left,
    numberstyle=\tiny,
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    stringstyle=\color{red},
    breaklines=true,
    showstringspaces=false
}

\title{\textbf{Chapitre 1 : Introduction à la Cryptographie\\et Sécurité Parfaite}}
\author{Cours de Sécurité Informatique - Niveau Universitaire\\Partie 1 : Cryptographie à Clé Secrète}
\date{\today}

\begin{document}

\maketitle
\tableofcontents
\newpage

%=============================================================================
\section{Introduction}
%=============================================================================

\subsection{Objectifs du chapitre}

Ce chapitre introduit les concepts fondamentaux de la cryptographie moderne et présente la notion de \textbf{sécurité parfaite} (perfect security) telle que formalisée par Claude Shannon en 1949. Nous étudierons :

\begin{itemize}[leftmargin=*]
    \item Les notions de base : plaintext, ciphertext, clé, chiffrement, déchiffrement
    \item Les principes de Kerckhoffs et la sécurité moderne
    \item La définition formelle de la sécurité parfaite
    \item Le One-Time Pad : seul chiffre prouvé parfaitement sécurisé
    \item Les limitations fondamentales de la sécurité parfaite
    \item Les propriétés du XOR et leur importance cryptographique
\end{itemize}

\subsection{Contexte historique}

La cryptographie a évolué d'un art empirique à une science mathématique rigoureuse :

\begin{itemize}[leftmargin=*]
    \item \textbf{Antiquité} : Chiffres de substitution (César, Vigenère)
    \item \textbf{1917} : Invention du One-Time Pad par Gilbert Vernam
    \item \textbf{1949} : Shannon formalise la sécurité parfaite dans ``Communication Theory of Secrecy Systems''
    \item \textbf{1976} : Diffie-Hellman révolutionne avec la cryptographie à clé publique
    \item \textbf{Aujourd'hui} : Cryptographie basée sur la complexité computationnelle
\end{itemize}

%=============================================================================
\section{Notions fondamentales}
%=============================================================================

\subsection{Définition d'un système cryptographique}

\begin{defbox}
\textbf{Système de chiffrement (Encryption Scheme)}

Un système de chiffrement est un tuple $(\M, \K, \C, \Enc, \Dec)$ où :
\begin{itemize}
    \item $\M$ : espace des messages clairs (plaintexts)
    \item $\K$ : espace des clés (key space)
    \item $\C$ : espace des messages chiffrés (ciphertexts)
    \item $\Enc : \K \times \M \to \C$ : algorithme de chiffrement
    \item $\Dec : \K \times \C \to \M$ : algorithme de déchiffrement
\end{itemize}

\textbf{Propriété de correction} : Pour tout $k \in \K$ et $m \in \M$ :
\[
\Dec(k, \Enc(k, m)) = m
\]
\end{defbox}

\subsection{Notations}

Nous adoptons les notations suivantes :
\begin{itemize}[leftmargin=*]
    \item $m$ : message clair (plaintext)
    \item $k$ : clé (key)
    \item $c$ : message chiffré (ciphertext)
    \item $c = \Enc_k(m)$ ou $c = \Enc(k,m)$ : chiffrement de $m$ avec la clé $k$
    \item $m = \Dec_k(c)$ ou $m = \Dec(k,c)$ : déchiffrement de $c$ avec la clé $k$
    \item $\bits^n$ : ensemble des chaînes binaires de longueur $n$
    \item $\bits^*$ : ensemble des chaînes binaires de longueur arbitraire
    \item $|x|$ : longueur de la chaîne $x$
    \item $x \xleftarrow{\$} X$ : $x$ tiré uniformément aléatoirement dans $X$
\end{itemize}

\subsection{Exemple : Chiffre de César}

Le chiffre de César est un exemple classique (bien qu'obsolète) de chiffrement par substitution.

\begin{exbox}
\textbf{Chiffre de César}

\begin{itemize}
    \item $\M = \C = \{A, B, \ldots, Z\}^*$ : messages en lettres majuscules
    \item $\K = \{0, 1, \ldots, 25\}$ : décalages possibles
    \item $\Enc_k(m)$ : décaler chaque lettre de $m$ de $k$ positions dans l'alphabet
    \item $\Dec_k(c)$ : décaler chaque lettre de $c$ de $-k$ positions (ou $26-k$)
\end{itemize}

\textbf{Exemple concret} :
\begin{itemize}
    \item Message : HELLO
    \item Clé : $k = 3$
    \item Chiffrement : KHOOR ($H+3=K, E+3=H, \ldots$)
    \item Déchiffrement : HELLO ($K-3=H, H-3=E, \ldots$)
\end{itemize}

\textbf{Faiblesse} : Seulement 26 clés possibles $\Rightarrow$ attaque par force brute triviale !
\end{exbox}

%=============================================================================
\section{Principes de Kerckhoffs}
%=============================================================================

\subsection{Énoncé des principes}

En 1883, Auguste Kerckhoffs énonce six principes pour la cryptographie militaire. Le plus important est devenu un dogme de la cryptographie moderne :

\begin{thmbox}
\textbf{Principe de Kerckhoffs (moderne)}

\textit{La sécurité d'un système cryptographique ne doit reposer que sur le secret de la clé, jamais sur le secret de l'algorithme.}

En d'autres termes : même si l'adversaire connaît parfaitement les algorithmes $\Enc$ et $\Dec$, il ne doit pas pouvoir casser le système sans connaître la clé $k$.
\end{thmbox}

\subsection{Justifications}

Ce principe se justifie par plusieurs arguments pratiques et théoriques :

\begin{enumerate}[leftmargin=*]
    \item \textbf{Secret difficile à maintenir} : Les algorithmes finissent toujours par fuiter (reverse engineering, traîtres, captures)
    \item \textbf{Standardisation} : Permet d'utiliser des algorithmes publics, standardisés et largement testés
    \item \textbf{Analyse de sécurité} : Une communauté mondiale peut analyser et auditer les algorithmes
    \item \textbf{Renouvellement des clés} : Plus facile de changer une clé compromise qu'un algorithme entier
    \item \textbf{Principe de Pareto} : Concentrer les efforts de protection sur la gestion des clés
\end{enumerate}

\begin{warnbox}
\textbf{Security through obscurity}

La ``sécurité par l'obscurité'' (cacher l'algorithme) est une mauvaise pratique universellement rejetée en cryptographie moderne. Les algorithmes secrets sont toujours faibles car non audités.
\end{warnbox}

%=============================================================================
\section{Sécurité parfaite (Perfect Security)}
%=============================================================================

\subsection{Modèle de l'adversaire}

Avant de définir la sécurité, nous devons préciser le modèle d'attaque :

\begin{itemize}[leftmargin=*]
    \item \textbf{Ciphertext-only attack} : L'adversaire observe uniquement $c = \Enc_k(m)$
    \item \textbf{Known-plaintext attack} : L'adversaire connaît des paires $(m_i, c_i)$
    \item \textbf{Chosen-plaintext attack (CPA)} : L'adversaire peut chiffrer des messages de son choix
    \item \textbf{Chosen-ciphertext attack (CCA)} : L'adversaire peut aussi déchiffrer des ciphertexts
\end{itemize}

Dans ce chapitre, nous considérons l'attaque la plus faible : \textbf{ciphertext-only}.

\subsection{Définition de Shannon}

Shannon a formalisé la notion intuitive de ``sécurité parfaite'' : le ciphertext ne révèle \textbf{aucune information} sur le plaintext.

\begin{defbox}
\textbf{Sécurité Parfaite (Perfect Secrecy)}

Un système de chiffrement $(\M, \K, \C, \Enc, \Dec)$ a la \textbf{sécurité parfaite} si pour tout $m \in \M$ et tout $c \in \C$ :

\[
\Pr[M = m \mid C = c] = \Pr[M = m]
\]

où la probabilité est prise sur le choix uniforme de la clé $K \xleftarrow{\$} \K$ et $C = \Enc_K(M)$.

\textbf{Interprétation} : Observer le ciphertext $c$ ne change pas la probabilité a priori du message $m$. L'adversaire n'apprend rien !
\end{defbox}

\subsection{Définition équivalente}

Une définition équivalente (souvent plus pratique) est :

\begin{proposition}
Un système a la sécurité parfaite si et seulement si pour tous $m_0, m_1 \in \M$ et $c \in \C$ :
\[
\Pr[\Enc_K(m_0) = c] = \Pr[\Enc_K(m_1) = c]
\]
où $K \xleftarrow{\$} \K$.

\textbf{Interprétation} : Le ciphertext $c$ est équiprobable quel que soit le message chiffré. Impossibilité de distinguer !
\end{proposition}

\begin{proof}
Par le théorème de Bayes :
\[
\Pr[M = m \mid C = c] = \frac{\Pr[C = c \mid M = m] \cdot \Pr[M = m]}{\Pr[C = c]}
\]

La sécurité parfaite impose $\Pr[M = m \mid C = c] = \Pr[M = m]$, donc :
\[
\Pr[C = c \mid M = m] = \Pr[C = c] \quad \forall m, c
\]

Comme $\Pr[C = c \mid M = m] = \Pr[\Enc_K(m) = c]$ (clé uniforme), on obtient l'équivalence.
\end{proof}

%=============================================================================
\section{Le One-Time Pad (OTP)}
%=============================================================================

\subsection{Construction}

Le \textbf{One-Time Pad} (masque jetable), inventé par Gilbert Vernam en 1917, est le seul système prouvé parfaitement sécurisé.

\begin{defbox}
\textbf{One-Time Pad (OTP)}

\begin{itemize}
    \item $\M = \C = \K = \bits^n$ : messages, clés et ciphertexts de longueur $n$ bits
    \item $\Gen$ : Choisir $k \xleftarrow{\$} \bits^n$ uniformément aléatoirement
    \item $\Enc_k(m) = m \xor k$ : XOR bit-à-bit
    \item $\Dec_k(c) = c \xor k$ : XOR bit-à-bit (identique !)
\end{itemize}

\textbf{Propriété de correction} :
\[
\Dec_k(\Enc_k(m)) = (m \xor k) \xor k = m \xor (k \xor k) = m \xor 0^n = m
\]
\end{defbox}

\subsection{Rappel : Propriétés du XOR}

L'opération XOR ($\xor$) a des propriétés cruciales :

\begin{enumerate}[leftmargin=*]
    \item \textbf{Commutativité} : $a \xor b = b \xor a$
    \item \textbf{Associativité} : $(a \xor b) \xor c = a \xor (b \xor c)$
    \item \textbf{Élément neutre} : $a \xor 0 = a$
    \item \textbf{Inverse} : $a \xor a = 0$
    \item \textbf{Randomisation parfaite} : Si $k \xleftarrow{\$} \bits^n$, alors $m \xor k$ est uniforme sur $\bits^n$, indépendamment de $m$ !
\end{enumerate}

La propriété 5 est \textbf{la clé} de la sécurité du OTP.

\subsection{Théorème de sécurité}

\begin{thmbox}
\textbf{Théorème : Le One-Time Pad a la sécurité parfaite}

Le OTP défini ci-dessus satisfait la sécurité parfaite au sens de Shannon.
\end{thmbox}

\begin{proof}
Soit $m_0, m_1 \in \bits^n$ deux messages arbitraires et $c \in \bits^n$ un ciphertext arbitraire.

Il existe une unique clé $k_0 = m_0 \xor c$ telle que $\Enc_{k_0}(m_0) = c$.

De même, il existe une unique clé $k_1 = m_1 \xor c$ telle que $\Enc_{k_1}(m_1) = c$.

Puisque $K$ est tiré uniformément dans $\bits^n$ :
\begin{align*}
\Pr[\Enc_K(m_0) = c] &= \Pr[K = k_0] = \frac{1}{2^n} \\
\Pr[\Enc_K(m_1) = c] &= \Pr[K = k_1] = \frac{1}{2^n}
\end{align*}

Donc $\Pr[\Enc_K(m_0) = c] = \Pr[\Enc_K(m_1) = c]$ pour tous $m_0, m_1, c$. Par la définition équivalente, le OTP a la sécurité parfaite. \qed
\end{proof}

\subsection{Exemple numérique}

\begin{exbox}
\textbf{OTP avec des bits}

\begin{itemize}
    \item Message : $m = 11010011$
    \item Clé (aléatoire) : $k = 10110101$
    \item Chiffrement : $c = m \xor k = 01100110$
    \item Déchiffrement : $m' = c \xor k = 01100110 \xor 10110101 = 11010011 = m$ \checkmark
\end{itemize}

\textbf{Observation} : Sans connaître $k$, $c = 01100110$ pourrait correspondre à \textbf{n'importe quel} message de 8 bits avec égale probabilité !
\end{exbox}

%=============================================================================
\section{Limitations de la sécurité parfaite}
%=============================================================================

\subsection{Théorème de Shannon}

Malgré sa sécurité parfaite, le OTP est rarement utilisé en pratique à cause de limitations fondamentales prouvées par Shannon.

\begin{thmbox}
\textbf{Théorème de Shannon (1949)}

Soit $(\M, \K, \C, \Enc, \Dec)$ un système avec sécurité parfaite. Alors :
\[
|\K| \geq |\M|
\]

En particulier, si $\M = \bits^n$, alors $|\K| \geq 2^n$.

\textbf{Conséquence} : La clé doit être au moins aussi longue que le message pour avoir la sécurité parfaite !
\end{thmbox}

\begin{proof}[Idée de la preuve]
Supposons par l'absurde que $|\K| < |\M|$. Soit $c \in \C$ un ciphertext observé.

L'ensemble des plaintexts possibles pour $c$ est :
\[
\M_c = \{ \Dec_k(c) : k \in \K \}
\]

Puisque $|\K| < |\M|$, il existe au moins un $m^* \in \M \setminus \M_c$ qui ne peut jamais produire $c$ avec aucune clé.

Donc $\Pr[\Enc_K(m^*) = c] = 0 \neq \Pr[\Enc_K(m) = c]$ pour $m \in \M_c$, ce qui contredit la sécurité parfaite. \qed
\end{proof}

\subsection{Conséquences pratiques}

Le théorème de Shannon impose des contraintes rédhibitoires :

\begin{enumerate}[leftmargin=*]
    \item \textbf{Clés énormes} : Chiffrer 1 GB nécessite une clé de 1 GB !
    \item \textbf{Distribution difficile} : Échanger de longues clés de manière sécurisée est un problème aussi difficile que d'échanger le message lui-même
    \item \textbf{Usage unique} : Réutiliser la clé brise totalement la sécurité (voir section suivante)
    \item \textbf{Pas de transmission multiple} : Chaque message nécessite une nouvelle clé de longueur égale
\end{enumerate}

\begin{warnbox}
\textbf{Impossibilité pratique}

Pour la plupart des applications modernes (communication Internet, chiffrement de disques, etc.), la sécurité parfaite est \textbf{inapplicable}. C'est pourquoi la cryptographie moderne s'appuie sur la \textbf{sécurité computationnelle} (chapitre suivant).
\end{warnbox}

\subsection{Attaque par réutilisation de clé}

La réutilisation de la clé OTP est catastrophique :

\begin{example}
\textbf{Two-Time Pad Attack}

Supposons qu'Alice réutilise la même clé $k$ pour chiffrer deux messages $m_1$ et $m_2$ :
\begin{align*}
c_1 &= m_1 \xor k \\
c_2 &= m_2 \xor k
\end{align*}

L'adversaire observe $c_1$ et $c_2$. Il peut calculer :
\[
c_1 \xor c_2 = (m_1 \xor k) \xor (m_2 \xor k) = m_1 \xor m_2
\]

Le XOR des deux plaintexts révèle beaucoup d'information ! Si les messages sont en anglais, on peut exploiter les fréquences des lettres, structures linguistiques, etc. pour retrouver $m_1$ et $m_2$.

\textbf{Exemple historique} : Le projet VENONA (1943-1980) a décrypté des milliers de messages soviétiques grâce à des réutilisations de clés OTP.
\end{example}

%=============================================================================
\section{Applications historiques}
%=============================================================================

\subsection{Téléphone rouge Moscou-Washington}

Durant la Guerre Froide, le ``téléphone rouge'' (hotline) entre le Kremlin et la Maison Blanche utilisait le OTP pour les communications sensibles :

\begin{itemize}[leftmargin=*]
    \item Clés pré-distribuées physiquement par valise diplomatique
    \item Machines de chiffrement spécialisées (ex : ETCRRM)
    \item Destruction sécurisée des clés après usage
    \item Génération de clés par processus physiques aléatoires (bruit thermique)
\end{itemize}

\subsection{NSA et renseignement}

La NSA a utilisé (et utilise probablement encore) le OTP pour :
\begin{itemize}[leftmargin=*]
    \item Communications avec agents en territoire hostile
    \item Messages ultra-sensibles de niveau présidentiel
    \item Systèmes de commande nucléaire
\end{itemize}

Ces usages sont justifiés car :
\begin{itemize}
    \item Volumes de données faibles (messages courts)
    \item Budget illimité pour la distribution de clés
    \item Enjeux de sécurité absolus
\end{itemize}

%=============================================================================
\section{Travaux dirigés}
%=============================================================================

\subsection{Exercices théoriques}

\begin{enumerate}
    \item \textbf{Sécurité du chiffre de César} \\
    Montrer formellement que le chiffre de César n'a pas la sécurité parfaite.

    \item \textbf{Variante du OTP} \\
    Considérer le système suivant sur $\bits^n$ : \\
    $\Enc_k(m) = (m \xor k) \mathbin{\|} k$ \\
    où $\mathbin{\|}$ dénote la concaténation. Ce système a-t-il la sécurité parfaite ? Pourquoi ?

    \item \textbf{OTP avec clé courte} \\
    Soit $m \in \bits^{2n}$ et $k \in \bits^n$ avec $|k| = n < 2n = |m|$. On définit : \\
    $\Enc_k(m) = m \xor (k \mathbin{\|} k)$ \\
    (la clé est répétée). Montrer que ce système n'a pas la sécurité parfaite.

    \item \textbf{Indistinguabilité} \\
    Montrer l'équivalence entre les deux définitions de la sécurité parfaite données en section 4.

    \item \textbf{Borne inférieure sur $|\C|$} \\
    Montrer que si un système a la sécurité parfaite, alors $|\C| \geq |\M|$.
\end{enumerate}

\subsection{Exercices pratiques}

Les notebooks suivants implémentent et explorent les concepts de ce chapitre :

\begin{itemize}
    \item \texttt{01_demo_otp.ipynb} : Implémentation du One-Time Pad
    \item \texttt{01_demo_xor_properties.ipynb} : Exploration des propriétés du XOR
    \item \texttt{01_exercices.ipynb} : Exercices pratiques guidés
\end{itemize}

\textbf{Exercices proposés} :
\begin{enumerate}
    \item Implémenter OTP et vérifier la correction
    \item Two-Time Pad attack : casser des messages réutilisant la clé
    \item Statistiques : vérifier expérimentalement l'uniformité de $m \xor k$
    \item Attaque par fréquence des lettres sur messages chiffrés avec clé réutilisée
\end{enumerate}

%=============================================================================
\section{Ressources complémentaires}
%=============================================================================

\subsection{Références}

\begin{itemize}[leftmargin=*]
    \item \textbf{Article fondateur} : Shannon, C. E. (1949). ``Communication Theory of Secrecy Systems''. Bell System Technical Journal, 28(4), 656-715.

    \item \textbf{Livre de référence} : Rosulek, M. (2021). ``The Joy of Cryptography'', Chapitre 2. \\
    \url{https://joyofcryptography.com/pdf/book.pdf}

    \item \textbf{Cryptographie moderne} : Katz, J., \& Lindell, Y. (2020). ``Introduction to Modern Cryptography'' (3e éd.). CRC Press.

    \item \textbf{Projet VENONA} : NSA. ``The VENONA Story''. \\
    \url{https://www.nsa.gov/portals/75/documents/news-features/declassified-documents/venona/}
\end{itemize}

\subsection{Cours en ligne}

\begin{itemize}[leftmargin=*]
    \item Coursera : ``Cryptography I'' par Dan Boneh (Stanford)
    \item MIT OpenCourseWare : 6.857 Computer and Network Security
    \item Christof Paar : Introduction to Cryptography (YouTube)
\end{itemize}

%=============================================================================
\section{Conclusion}
%=============================================================================

Ce chapitre a posé les fondations de la cryptographie moderne :

\begin{itemize}[leftmargin=*]
    \item Les principes de Kerckhoffs restent valides aujourd'hui
    \item La sécurité parfaite de Shannon est une notion théorique forte mais impraticable
    \item Le One-Time Pad est le seul système prouvé parfaitement sécurisé
    \item Le théorème de Shannon impose des limites fondamentales : $|\K| \geq |\M|$
    \item En pratique, on abandonne la sécurité parfaite pour la sécurité computationnelle
\end{itemize}

Le chapitre suivant introduira les \textbf{chiffrements par flot et par bloc}, qui relaxent l'exigence de sécurité parfaite pour obtenir des systèmes pratiques avec des clés courtes réutilisables, au prix d'hypothèses de calcul (difficulté de certains problèmes algorithmiques).

\vfill

\begin{center}
\textit{``The enemy knows the system.''} \\
--- Claude Shannon, citant Auguste Kerckhoffs
\end{center}

\end{document}

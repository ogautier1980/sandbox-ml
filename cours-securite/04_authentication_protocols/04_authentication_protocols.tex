\documentclass[11pt,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
%\usepackage{lmodern}  % Package non disponible dans le container
\usepackage{geometry,amsmath,amssymb,amsthm,hyperref,enumitem}
\usepackage[most]{tcolorbox}
\usepackage{listings}
\usepackage{algorithm}
\usepackage{algorithmic}

\geometry{margin=2.5cm}

\definecolor{defcolor}{RGB}{0,102,204}
\definecolor{warncolor}{RGB}{204,0,0}
\definecolor{excolor}{RGB}{0,153,76}

\newtheorem{definition}{Définition}[section]
\newtheorem{theorem}{Théorème}[section]
\newtheorem{example}{Exemple}[section]

\newtcolorbox{defbox}{breakable,colback=defcolor!5!white,colframe=defcolor!75!black,title=Définition}
\newtcolorbox{warnbox}{breakable,colback=warncolor!5!white,colframe=warncolor!75!black,title=Avertissement}
\newtcolorbox{exbox}{breakable,colback=excolor!5!white,colframe=excolor!75!black,title=Exemple}

\lstset{
    basicstyle=\ttfamily\small,
    breaklines=true,
    frame=single,
    language=Python
}

\title{\textbf{Chapitre 4 : Protocoles d'Authentification\\Authentication Protocols \& Password Security}}
\author{Cours de Sécurité Informatique - Niveau Universitaire\\Partie 2 : Protocoles d'Authentification}
\date{\today}

\begin{document}

\maketitle
\tableofcontents
\newpage

%=============================================================================
\section{Introduction}
%=============================================================================

\subsection{Objectifs du chapitre}

L'authentification est le processus de vérification de l'identité d'une entité (utilisateur, système, service). Ce chapitre couvre :

\begin{itemize}
    \item Construire des protocoles d'authentification à partir de primitives cryptographiques
    \item Authentification par mot de passe : défis et vulnérabilités
    \item Attaques cryptanalytiques sur les protocoles à mot de passe
    \item Protocoles Challenge-Response
    \item Authentification multi-facteurs (MFA)
\end{itemize}

\subsection{Définitions}

\begin{defbox}
\textbf{Authentification} : Processus de vérification qu'une entité est bien celle qu'elle prétend être.

\textbf{Trois facteurs d'authentification} :
\begin{itemize}
    \item \textbf{Quelque chose que vous savez} : mot de passe, PIN
    \item \textbf{Quelque chose que vous avez} : token, carte à puce, smartphone
    \item \textbf{Quelque chose que vous êtes} : biométrie (empreinte, iris, voix)
\end{itemize}
\end{defbox}

\textbf{Distinction importante} :
\begin{itemize}
    \item \textbf{Authentification} : Vérifier l'identité
    \item \textbf{Autorisation} : Déterminer les permissions/droits d'accès
\end{itemize}

%=============================================================================
\section{Authentification par mot de passe}
%=============================================================================

\subsection{Modèle basique}

Le modèle le plus simple : l'utilisateur prouve son identité en fournissant un mot de passe secret.

\textbf{Protocole naïf} :
\begin{enumerate}
    \item Client envoie : $(username, password)$
    \item Serveur vérifie : $password \stackrel{?}{=} stored\_password$
\end{enumerate}

\begin{warnbox}
\textbf{Problèmes majeurs} :
\begin{itemize}
    \item Transmission en clair : vulnérable à l'écoute (sniffing)
    \item Stockage en clair : une compromission du serveur révèle tous les mots de passe
    \item Pas de protection contre le rejeu (replay attack)
\end{itemize}
\end{warnbox}

\subsection{Stockage sécurisé : Hachage des mots de passe}

\textbf{Principe} : Stocker $h = H(password)$ au lieu de $password$ en clair.

\textbf{Vérification} :
\begin{enumerate}
    \item Client envoie : $(username, password)$
    \item Serveur calcule : $h' = H(password)$
    \item Serveur compare : $h' \stackrel{?}{=} h$
\end{enumerate}

\textbf{Propriété requise} : $H$ doit être une fonction de hachage cryptographique (SHA-256, SHA-3, etc.)

\begin{warnbox}
\textbf{Attaque par dictionnaire} : Si les mots de passe sont faibles, l'attaquant peut pré-calculer $H(w)$ pour tous les mots $w$ du dictionnaire et comparer avec les hachés volés.

\textbf{Rainbow Tables} : Tables pré-calculées optimisées pour inverser les fonctions de hachage.
\end{warnbox}

\subsection{Salage (Salting)}

\textbf{Solution} : Ajouter un sel aléatoire unique par utilisateur.

\textbf{Stockage} : $(salt, h)$ où $h = H(salt \| password)$

\textbf{Vérification} :
\begin{enumerate}
    \item Serveur récupère $(salt, h)$ pour l'utilisateur
    \item Serveur calcule : $h' = H(salt \| password)$
    \item Serveur compare : $h' \stackrel{?}{=} h$
\end{enumerate}

\textbf{Avantages} :
\begin{itemize}
    \item Les rainbow tables deviennent inutiles (un sel différent par utilisateur)
    \item Deux utilisateurs avec le même mot de passe auront des hachés différents
    \item Force l'attaquant à attaquer chaque mot de passe individuellement
\end{itemize}

\subsection{Rainbow Tables et Tables de Hellman}

\subsubsection{Motivation : Compromis temps-mémoire}

\textbf{Problème} : Pour casser un mot de passe haché sans sel, deux approches naïves :

\begin{enumerate}
    \item \textbf{Attaque en temps} : Calculer $H(w)$ pour chaque tentative $w$
    \begin{itemize}
        \item Avantage : Mémoire minimale
        \item Inconvénient : Très lent ($10^9$ hash/sec $\times$ $10^{10}$ mots = $10^4$ secondes)
    \end{itemize}

    \item \textbf{Table de lookup complète} : Pré-calculer et stocker $(w, H(w))$ pour tous les mots $w$
    \begin{itemize}
        \item Avantage : Recherche instantanée
        \item Inconvénient : Espace mémoire gigantesque ($10^{10}$ entrées $\times$ 40 bytes = 400 GB)
    \end{itemize}
\end{enumerate}

\textbf{Solution} : Compromis temps-mémoire (Time-Memory Trade-Off, TMTO)

\subsubsection{Tables de Hellman classiques}

\textbf{Principe} : Martin Hellman (1980) propose d'utiliser des \textbf{chaînes de réduction}.

\textbf{Fonction de réduction} : $R : \{0,1\}^n \to \text{Passwords}$

Une fonction \textit{déterministe} qui transforme un hash en un mot de passe.

\textbf{Exemple} : $R(h) = h \mod 10^6$ (retourne les 6 derniers chiffres comme mot de passe)

\textbf{Construction d'une chaîne Hellman} :

\begin{verbatim}
p₀ --H--> h₁ --R--> p₁ --H--> h₂ --R--> p₂ --H--> ... --R--> pₜ
\end{verbatim}

\textbf{Stockage} : On ne stocke que $(p_0, p_t)$ (début et fin de chaîne)

\textbf{Recherche} : Pour inverser un hash $h^*$ :
\begin{enumerate}
    \item Appliquer $R(h^*)$ puis continuer la chaîne jusqu'à $t$ étapes
    \item Si on trouve $p_t$ dans la table, recalculer la chaîne depuis $p_0$
    \item Trouver le mot de passe qui produit $h^*$
\end{enumerate}

\textbf{Paramètres} :
\begin{itemize}
    \item $m$ = nombre de chaînes
    \item $t$ = longueur de chaque chaîne
    \item Couverture : $\approx mt$ mots de passe couverts
    \item Espace : $O(m)$ (stocker $(p_0, p_t)$ pour chaque chaîne)
    \item Temps de recherche : $O(t^2)$ opérations
\end{itemize}

\textbf{Problème majeur : Collisions de chaînes (Merging chains)}

\begin{verbatim}
Chaîne 1: password --H--> a3f5... --R--> admin123 --H--> ...
Chaîne 2: letmein  --H--> a3f5... --R--> admin123 --H--> ...
                           ^
                           Collision ! Les chaînes fusionnent
\end{verbatim}

Si deux chaînes produisent le même hash intermédiaire, elles fusionnent et deviennent identiques. Résultat : \textbf{perte de couverture} (environ 50\% des chaînes peuvent fusionner).

\subsubsection{Rainbow Tables (Oechslin, 2003)}

\textbf{Idée clé} : Utiliser une fonction de réduction \textbf{différente à chaque étape}.

\textbf{Construction d'une chaîne Rainbow} :

\begin{verbatim}
p₀ --H--> h₁ --R₁--> p₁ --H--> h₂ --R₂--> p₂ --H--> ... --Rₜ--> pₜ
\end{verbatim}

\textbf{Avantage} : Les collisions de chaînes sont \textbf{éliminées} !

\begin{verbatim}
Chaîne 1: password --H--> a3f5... --R₁--> admin123 --H--> b2e8... --R₂--> ...
Chaîne 2: letmein  --H--> a3f5... --R₁--> user4567  --H--> c9d3... --R₂--> ...
                           ^                 ^
                       Même hash       Différents mots (R₁ différent)
                                      Pas de fusion !
\end{verbatim}

\textbf{Raison} : Même si $h_1$ est identique, $R_1(h_1)$ et $R_2(h_1)$ seront différents car $R_1 \neq R_2$.

\textbf{Recherche dans une Rainbow Table} :

Pour inverser $h^*$, tester toutes les positions possibles :
\begin{enumerate}
    \item Tester si $h^*$ est en position $t$ : calculer $R_t(h^*)$ et chercher dans les fins de chaînes
    \item Tester si $h^*$ est en position $t-1$ : calculer $R_{t}(H(R_{t-1}(h^*)))$ et chercher
    \item Continuer jusqu'à position 1
\end{enumerate}

Complexité : $O(t^2)$ opérations (comme Hellman), mais \textbf{meilleure couverture}.

\subsubsection{Comparaison Hellman vs Rainbow}

\begin{center}
\begin{tabular}{|l|c|c|}
\hline
\textbf{Caractéristique} & \textbf{Hellman} & \textbf{Rainbow} \\
\hline
Fonction de réduction & 1 seule ($R$) & $t$ différentes ($R_1, \ldots, R_t$) \\
Collisions de chaînes & Oui (50\% fusionnent) & Non (éliminées) \\
Couverture ($m$ chaînes, longueur $t$) & $\sim 0.5 \cdot mt$ & $\sim 0.86 \cdot mt$ \\
Temps de recherche & $O(t^2)$ & $O(t^2)$ \\
Espace mémoire & $O(m)$ & $O(m)$ \\
Efficacité & Moyenne & Excellente \\
\hline
\end{tabular}
\end{center}

\textbf{Conclusion} : Rainbow tables sont $\sim 2\times$ plus efficaces que Hellman pour même espace.

\subsubsection{Exemple concret}

\textbf{Paramètres réalistes} :
\begin{itemize}
    \item Espace des mots de passe : alphanumériques 8 caractères = $62^8 \approx 2.18 \times 10^{14}$
    \item Hash : MD5 (128 bits, rapide)
    \item Chaînes : $m = 10^8$ (100 millions)
    \item Longueur : $t = 10^6$ (1 million)
    \item Couverture : $\sim 0.86 \times 10^8 \times 10^6 = 8.6 \times 10^{13}$ (40\% de l'espace)
\end{itemize}

\textbf{Espace disque} :
\begin{itemize}
    \item Stockage : $(p_0, p_t)$ pour $10^8$ chaînes
    \item Taille : $10^8 \times 16 \text{ bytes} = 1.6 \text{ GB}$
\end{itemize}

\textbf{Temps de recherche} : $\sim t^2 / 2 = 5 \times 10^{11}$ hash (quelques minutes sur GPU moderne)

\subsubsection{Défense : Le salage rend les Rainbow Tables inutiles}

\textbf{Avec sel aléatoire unique} :

\begin{verbatim}
User 1: password + sel₁ --H--> hash₁
User 2: password + sel₂ --H--> hash₂  (hash₁ ≠ hash₂)
\end{verbatim}

\textbf{Impact sur Rainbow Tables} :

Pour casser $n$ utilisateurs avec des sels différents, l'attaquant doit :
\begin{itemize}
    \item Soit générer $n$ Rainbow Tables différentes (1 par sel) $\Rightarrow$ Espace : $n \times 1.6$ GB
    \item Soit attaquer individuellement chaque utilisateur (pas d'amortissement)
\end{itemize}

\textbf{Calcul} : Avec sel de 128 bits :
\begin{itemize}
    \item Nombre de sels possibles : $2^{128} \approx 3.4 \times 10^{38}$
    \item Espace requis : $2^{128} \times 1.6 \text{ GB} \approx 10^{38} \text{ exaoctets}$
    \item \textbf{Totalement infaisable !}
\end{itemize}

\begin{warnbox}
\textbf{Conclusion} : Le salage (avec sel $\geq 128$ bits) rend les Rainbow Tables et tables de Hellman \textbf{complètement inefficaces}.

C'est pourquoi le salage est \textbf{obligatoire} dans tout système moderne de stockage de mots de passe.
\end{warnbox}

\subsection{Fonctions de dérivation de clés (KDF)}

Pour ralentir les attaques par force brute, utiliser des fonctions spécialement conçues :

\begin{itemize}
    \item \textbf{PBKDF2} : Itère $H$ de nombreuses fois (ex: 100,000 itérations)
    \item \textbf{bcrypt} : Fonction coûteuse en calcul, paramètre de coût ajustable
    \item \textbf{scrypt} : Coûteuse en mémoire (résiste aux attaques GPU/ASIC)
    \item \textbf{Argon2} (recommandé) : Gagnant du Password Hashing Competition (2015)
\end{itemize}

\begin{exbox}
\textbf{Exemple bcrypt} :

Stocker : $hash = \text{bcrypt}(password, salt, cost=12)$

Le paramètre $cost=12$ signifie $2^{12} = 4096$ itérations internes.
\end{exbox}

%=============================================================================
\section{Protocoles Challenge-Response}
%=============================================================================

\subsection{Principe}

Éviter de transmettre le mot de passe (même haché) sur le réseau.

\textbf{Idée} : Le serveur envoie un challenge aléatoire, le client prouve qu'il connaît le secret en répondant correctement.

\subsection{Protocole basé sur MAC}

\textbf{Setup} : Client et serveur partagent une clé secrète $k$ (dérivée du mot de passe)

\textbf{Protocole} :
\begin{enumerate}
    \item Client $\to$ Serveur : $username$
    \item Serveur $\to$ Client : $challenge$ (nonce aléatoire)
    \item Client $\to$ Serveur : $response = \text{MAC}_k(challenge)$
    \item Serveur vérifie : $response \stackrel{?}{=} \text{MAC}_k(challenge)$
\end{enumerate}

\textbf{Avantages} :
\begin{itemize}
    \item Le secret n'est jamais transmis
    \item Protection contre le rejeu (challenge différent à chaque fois)
\end{itemize}

\subsection{Protocole SCRAM (Salted Challenge Response Authentication Mechanism)}

Utilisé notamment par MongoDB, PostgreSQL.

\textbf{Caractéristiques} :
\begin{itemize}
    \item Authentification mutuelle (client et serveur s'authentifient)
    \item Utilise PBKDF2 pour dériver les clés
    \item Résiste aux attaques par dictionnaire même si l'attaquant observe le trafic
    \item Le serveur ne stocke pas le mot de passe en clair
\end{itemize}

%=============================================================================
\section{Attaques sur les protocoles à mot de passe}
%=============================================================================

\subsection{Attaque par dictionnaire en ligne}

\textbf{Méthode} : L'attaquant essaie directement les mots de passe courants contre le service.

\textbf{Défenses} :
\begin{itemize}
    \item \textbf{Rate limiting} : Limiter le nombre de tentatives par IP/compte
    \item \textbf{Account lockout} : Bloquer le compte après $n$ échecs (attention au DoS)
    \item \textbf{CAPTCHA} : Après plusieurs échecs
    \item \textbf{Monitoring} : Détecter les patterns d'attaque
\end{itemize}

\subsection{Attaque par dictionnaire hors ligne}

\textbf{Scénario} : L'attaquant obtient la base de données des hachés (breach)

\textbf{Méthode} : Calculer $H(w)$ pour chaque mot $w$ du dictionnaire et comparer

\textbf{Défenses} :
\begin{itemize}
    \item Salage (obligatoire)
    \item KDF lentes (PBKDF2, bcrypt, scrypt, Argon2)
    \item Politique de mots de passe forts
\end{itemize}

\subsection{Credential Stuffing}

\textbf{Méthode} : Utiliser des identifiants volés d'un site sur d'autres sites

\textbf{Problème} : Réutilisation de mots de passe entre services

\textbf{Défenses} :
\begin{itemize}
    \item Éducation des utilisateurs (ne pas réutiliser les mots de passe)
    \item Gestionnaires de mots de passe
    \item Détection de connexions anormales (géolocalisation, device fingerprinting)
\end{itemize}

\subsection{Phishing}

\textbf{Méthode} : Tromper l'utilisateur pour qu'il révèle son mot de passe sur un faux site

\textbf{Défenses} :
\begin{itemize}
    \item Formation des utilisateurs
    \item Authentification multi-facteurs (MFA)
    \item Certificats TLS et validation du domaine
\end{itemize}

\subsection{Man-in-the-Middle (MitM)}

\textbf{Méthode} : Intercepter la communication entre client et serveur

\textbf{Défenses} :
\begin{itemize}
    \item TLS/HTTPS obligatoire (chiffrement de bout en bout)
    \item Certificate pinning
    \item Protocoles Challenge-Response (pas de transmission du secret)
\end{itemize}

%=============================================================================
\section{Authentification multi-facteurs (MFA)}
%=============================================================================

\subsection{Principe}

Combiner plusieurs facteurs d'authentification indépendants.

\textbf{Exemple 2FA} : Mot de passe (ce que vous savez) + Code SMS (ce que vous avez)

\subsection{Types de seconds facteurs}

\begin{enumerate}
    \item \textbf{SMS/OTP} : Code à usage unique envoyé par SMS
    \begin{itemize}
        \item \textbf{Avantage} : Simple, compatible avec tous les téléphones
        \item \textbf{Inconvénient} : Vulnérable au SIM swapping, interception SMS
    \end{itemize}

    \item \textbf{TOTP (Time-based OTP)} : Google Authenticator, Authy
    \begin{itemize}
        \item Code généré localement basé sur l'heure et une clé secrète
        \item Standard : RFC 6238
        \item Plus sécurisé que SMS
    \end{itemize}

    \item \textbf{Hardware tokens} : YubiKey, clés de sécurité FIDO2
    \begin{itemize}
        \item \textbf{Avantage} : Très sécurisé, résiste au phishing
        \item \textbf{Inconvénient} : Coût, peut être perdu
    \end{itemize}

    \item \textbf{Biométrie} : Empreinte digitale, reconnaissance faciale
    \begin{itemize}
        \item \textbf{Avantage} : Pratique, difficile à voler
        \item \textbf{Inconvénient} : Impossible de "changer" si compromis
    \end{itemize}

    \item \textbf{Push notifications} : Duo, Microsoft Authenticator
    \begin{itemize}
        \item Notification sur smartphone à approuver
        \item Vulnérable à la fatigue d'authentification (MFA fatigue)
    \end{itemize}
\end{enumerate}

\subsection{FIDO2 et WebAuthn}

\textbf{Standard moderne} : Authentification sans mot de passe (passwordless)

\textbf{Principe} :
\begin{itemize}
    \item Utilise la cryptographie à clé publique
    \item Clé privée stockée dans un token hardware (YubiKey) ou TPM
    \item Résiste au phishing (validation du domaine intégrée)
    \item Pas de secret partagé avec le serveur
\end{itemize}

%=============================================================================
\section{Protocoles avancés}
%=============================================================================

\subsection{Password-Authenticated Key Exchange (PAKE)}

\textbf{Objectif} : Établir une clé de session à partir d'un mot de passe partagé

\textbf{Protocoles} :
\begin{itemize}
    \item \textbf{SRP (Secure Remote Password)} : Utilisé par Apple iCloud
    \item \textbf{SPAKE2} : Standardisé, simple et efficace
    \item \textbf{OPAQUE} : État de l'art, en cours de standardisation IETF
\end{itemize}

\textbf{Propriétés} :
\begin{itemize}
    \item Résiste aux attaques par dictionnaire en ligne
    \item Le serveur ne stocke pas de vérificateur permettant une attaque hors ligne
    \item Forward secrecy
\end{itemize}

\subsection{Zero-Knowledge Password Proof (ZKPP)}

\textbf{Principe} : Prouver la connaissance du mot de passe sans le révéler

\textbf{Application} : 1Password, Bitwarden (architecture zero-knowledge)

%=============================================================================
\section{Travaux pratiques}
%=============================================================================

\subsection{Exercices théoriques}

\begin{enumerate}
    \item \textbf{Analyse de protocole} : Montrer que le protocole naïf (envoi du mot de passe en clair) est vulnérable au rejeu.

    \item \textbf{Calcul de complexité} : Si un attaquant peut tester $10^9$ mots de passe/seconde, combien de temps faut-il pour casser un mot de passe de 8 caractères alphanumériques ?

    \item \textbf{Salage} : Expliquer pourquoi le salage rend les rainbow tables inefficaces.

    \item \textbf{TOTP} : Décrire le fonctionnement de TOTP. Quel est le rôle du temps dans ce protocole ?

    \item \textbf{MFA bypass} : Quelles sont les attaques possibles contre MFA par SMS ?
\end{enumerate}

\subsection{Exercices pratiques}

Les notebooks suivants implémentent et explorent les concepts de ce chapitre :

\begin{itemize}
    \item \texttt{04\_demo\_password\_hashing.ipynb} : Hachage avec sel, PBKDF2, bcrypt
    \item \texttt{04\_demo\_totp.ipynb} : Implémentation de TOTP (RFC 6238)
    \item \texttt{04\_demo\_challenge\_response.ipynb} : Protocole challenge-response avec HMAC
    \item \texttt{04\_exercices.ipynb} : Exercices guidés sur l'authentification
\end{itemize}

\textbf{Exercices proposés} :
\begin{enumerate}
    \item Implémenter le stockage sécurisé de mots de passe avec bcrypt
    \item Créer un générateur TOTP compatible avec Google Authenticator
    \item Simuler une attaque par dictionnaire et mesurer l'impact du coût bcrypt
    \item Analyser des dumps de bases de données réelles (rockyou.txt) et identifier les patterns de mots de passe faibles
\end{enumerate}

%=============================================================================
\section{Ressources complémentaires}
%=============================================================================

\subsection{Standards et RFCs}

\begin{itemize}
    \item RFC 6238 : TOTP (Time-Based One-Time Password)
    \item RFC 2898 : PBKDF2 (Password-Based Key Derivation Function)
    \item FIDO Alliance : Standards FIDO2/WebAuthn
    \item NIST SP 800-63B : Digital Identity Guidelines (Authentication)
\end{itemize}

\subsection{Outils pratiques}

\begin{itemize}
    \item \textbf{John the Ripper} : Outil de cracking de mots de passe
    \item \textbf{Hashcat} : Cracking GPU-accéléré
    \item \textbf{Have I Been Pwned} : Base de données de breaches (haveibeenpwned.com)
    \item \textbf{zxcvbn} : Librairie d'estimation de force de mots de passe (Dropbox)
\end{itemize}

\subsection{Lectures recommandées}

\begin{itemize}
    \item Bonneau et al. (2012). "The Quest to Replace Passwords"
    \item Herley \& van Oorschot (2012). "A Research Agenda Acknowledging the Persistence of Passwords"
    \item OWASP Authentication Cheat Sheet
\end{itemize}

%=============================================================================
\section{Conclusion}
%=============================================================================

\textbf{Points clés} :
\begin{itemize}
    \item Ne jamais stocker ou transmettre des mots de passe en clair
    \item Toujours utiliser un sel unique par utilisateur
    \item Utiliser des KDF lentes (Argon2, bcrypt, scrypt)
    \item L'authentification multi-facteurs est essentielle pour la sécurité moderne
    \item Les protocoles Challenge-Response évitent la transmission du secret
    \item Éduquer les utilisateurs sur les bonnes pratiques (gestionnaires de mots de passe, pas de réutilisation)
\end{itemize}

\textbf{Évolution} : Vers une authentification sans mot de passe (passwordless) avec FIDO2/WebAuthn.

\vspace{1cm}
\begin{center}
\textit{"The only secure password is the one you can't remember."} \\
— Troy Hunt, Have I Been Pwned
\end{center}

\end{document}

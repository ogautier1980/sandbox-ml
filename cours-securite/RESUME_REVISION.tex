\documentclass[11pt,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage{geometry,amsmath,amssymb,amsthm,hyperref,enumitem}
\usepackage[most]{tcolorbox}
\usepackage{listings}
\usepackage{booktabs}
\usepackage{longtable}

\geometry{margin=2.5cm}

\definecolor{defcolor}{RGB}{0,102,204}
\definecolor{warncolor}{RGB}{204,0,0}
\definecolor{excolor}{RGB}{0,153,76}
\definecolor{importantcolor}{RGB}{153,0,153}

\newtcolorbox{defbox}{breakable,colback=defcolor!5!white,colframe=defcolor!75!black,title=Définition}
\newtcolorbox{warnbox}{breakable,colback=warncolor!5!white,colframe=warncolor!75!black,title=Avertissement}
\newtcolorbox{exbox}{breakable,colback=excolor!5!white,colframe=excolor!75!black,title=Exemple}
\newtcolorbox{importantbox}{breakable,colback=importantcolor!5!white,colframe=importantcolor!75!black,title=Important}

\lstset{
    basicstyle=\ttfamily\small,
    breaklines=true,
    frame=single,
    language=Python
}

\title{\textbf{Résumé de Révision\\Sécurité Informatique}}
\author{Cours de Sécurité Informatique - Niveau Universitaire\\Préparation Examens Janvier 2024 \& 2025}
\date{\today}

\begin{document}

\maketitle

\begin{center}
\textit{Document complet de révision couvrant les 6 chapitres du cours}
\end{center}

\vspace{1cm}

\tableofcontents
\newpage

%==============================================================================
\section{Cryptographie Symétrique}
%==============================================================================

\subsection{Perfect Security (One-Time Pad)}

\begin{defbox}
\textbf{Perfect Security} : Un chiffrement a la perfect security si :
$$\Pr[M = m \mid C = c] = \Pr[M = m] \quad \forall m, c$$

L'observation du chiffré ne donne AUCUNE information sur le message.
\end{defbox}

\textbf{One-Time Pad (OTP)} :
\begin{itemize}
    \item Chiffrement : $c = m \oplus k$
    \item Déchiffrement : $m = c \oplus k$
    \item \textbf{Conditions} :
    \begin{itemize}
        \item Clé aussi longue que le message : $|K| = |M|$
        \item Clé uniformément aléatoire et usage unique
    \end{itemize}
\end{itemize}

\textbf{Théorème de Shannon} : Si $|M| > |K|$, alors pas de perfect security possible.

\textbf{Limitations OTP} :
\begin{itemize}
    \item Clé aussi longue que le message (impraticable)
    \item Clé à usage unique (distribution difficile)
    \item Sécurité inconditionnelle (même contre adversaire avec puissance infinie)
\end{itemize}

\subsection{Sécurité Computationnelle}

\textbf{Secure PRG (Pseudo-Random Generator)} :
$$\text{PRGadv}[A, G] := |\Pr[A(G(s)) = 1] - \Pr[A(r) = 1]|$$

où $s \leftarrow S$ (seed), $r \leftarrow R$ (vraiment aléatoire)

\begin{defbox}
$G$ est un \textbf{Secure PRG} si PRGadv$[A, G]$ est négligeable pour tout adversaire efficace (polynomial-time).
\end{defbox}

\textbf{Stream Cipher} : $c = m \oplus \text{PRG}(k)$

Exemples : RC4 (cassé), ChaCha20 (moderne)

\subsection{Block Ciphers}

\textbf{AES (Advanced Encryption Standard)} :
\begin{itemize}
    \item Taille de bloc : 128 bits
    \item Tailles de clés : 128, 192, 256 bits
    \item Structure : Substitution-Permutation Network (SPN)
\end{itemize}

\textbf{Modes d'opération} :

\begin{center}
\begin{tabular}{|l|l|c|c|c|}
\hline
\textbf{Mode} & \textbf{Chiffrement} & \textbf{Parallèle} & \textbf{IV} & \textbf{Sécurité} \\
\hline
ECB & $c_i = E(k, m_i)$ & Oui & Non & Patterns visibles \\
CBC & $c_i = E(k, m_i \oplus c_{i-1})$ & Non & Oui & Padding oracle \\
CTR & $c_i = m_i \oplus E(k, IV + i)$ & Oui & Oui & CPA-secure \\
\hline
\end{tabular}
\end{center}

\textbf{CPA Security} : L'adversaire peut choisir des messages et obtenir leurs chiffrés. CTR mode est CPA-secure, ECB ne l'est pas.

%==============================================================================
\section{Intégrité des Messages}
%==============================================================================

\subsection{Fonctions de Hachage Cryptographiques}

\textbf{Propriétés requises} :

\begin{enumerate}
    \item \textbf{Collision Resistance} : Difficile de trouver $m_1 \neq m_2$ tel que $H(m_1) = H(m_2)$
    \item \textbf{Pre-image Resistance} : Difficile de trouver $m$ tel que $H(m) = h$ (one-way)
    \item \textbf{Second Pre-image Resistance} : Difficile de trouver $m_2 \neq m_1$ tel que $H(m_1) = H(m_2)$
\end{enumerate}

\textbf{Exemples} :
\begin{itemize}
    \item SHA-256 : 256 bits, utilisé massivement
    \item SHA-3 (Keccak) : Différente structure (sponge construction)
    \item MD5, SHA-1 : CASSÉS, ne plus utiliser
\end{itemize}

\subsection{MAC (Message Authentication Code)}

\textbf{Objectif} : Authentifier l'intégrité d'un message avec une clé secrète partagée.

\textbf{HMAC (Hash-based MAC)} :
$$\text{HMAC}_k(m) = H\left((k \oplus \text{opad}) \| H((k \oplus \text{ipad}) \| m)\right)$$

Résiste aux collisions de $H$ sous-jacent.

\subsection{AEAD (Authenticated Encryption with Associated Data)}

\textbf{AES-GCM} : Combine chiffrement (CTR) + authentification (GMAC)
\begin{itemize}
    \item Chiffre et authentifie en une passe
    \item Données associées (AD) : métadonnées non chiffrées mais authentifiées
\end{itemize}

\newpage

%==============================================================================
\section{Protocoles d'Authentification}
%==============================================================================

\subsection{Hachage de Mots de Passe}

\begin{warnbox}
\textbf{Jamais faire} : \texttt{hash = SHA256(password)} (vulnérable aux rainbow tables !)

\textbf{Toujours faire} :
\begin{verbatim}
salt = random(16 bytes)
hash = bcrypt(password, salt, cost=12)
\end{verbatim}
\end{warnbox}

\textbf{Salting} :
\begin{itemize}
    \item Salt unique par utilisateur
    \item Rend les rainbow tables inutiles
    \item Stockage : (salt, hash)
\end{itemize}

\textbf{Password KDF (Key Derivation Functions)} :

\begin{center}
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Algorithme} & \textbf{Coût} & \textbf{Résistance} & \textbf{Recommandation} \\
\hline
SHA-256 & Très rapide & Faible & Jamais utiliser \\
PBKDF2 & Itérations (100k+) & Moyen & Acceptable \\
\textbf{bcrypt} & Cost (12-14) & Bon & \textbf{Recommandé} \\
\textbf{scrypt} & Mémoire + CPU & Excellent & Recommandé \\
\textbf{Argon2} & Mémoire + CPU & Meilleur & \textbf{Standard moderne} \\
\hline
\end{tabular}
\end{center}

\textbf{Benchmark bcrypt} (cost = 12) : ~300ms par hash sur CPU moderne

\subsection{Rainbow Tables et Tables de Hellman}

\textbf{Problème} : Comment casser un hash sans sel efficacement ?

\textbf{Approches naïves} :
\begin{enumerate}
    \item \textbf{Attaque en temps} : Calculer $H(w)$ pour chaque tentative (très lent)
    \item \textbf{Table complète} : Stocker $(w, H(w))$ pour tous les mots (énorme mémoire, 400 GB)
\end{enumerate}

\textbf{Solution : Compromis Temps-Mémoire (TMTO)}

\subsubsection{Tables de Hellman (1980)}

\textbf{Principe} : Chaînes de réduction avec UNE fonction $R$

\begin{verbatim}
p₀ --H--> h₁ --R--> p₁ --H--> h₂ --R--> p₂ --H--> ... --R--> pₜ
\end{verbatim}

\textbf{Stockage} : Seulement $(p_0, p_t)$ pour chaque chaîne

\textbf{Paramètres} :
\begin{itemize}
    \item $m$ chaînes de longueur $t$
    \item Couverture : $\sim 0.5 \times m \times t$ mots de passe (50\% à cause des collisions)
    \item Espace : $O(m)$ stockage
    \item Temps recherche : $O(t^2)$ opérations
\end{itemize}

\textbf{Problème : Collisions de chaînes} (Merging chains) : Si deux chaînes produisent le même hash intermédiaire, elles fusionnent. Perte de 50\% de couverture.

\subsubsection{Rainbow Tables (Oechslin, 2003)}

\textbf{Idée clé} : Utiliser des fonctions de réduction DIFFÉRENTES à chaque étape

\begin{verbatim}
p₀ --H--> h₁ --R₁--> p₁ --H--> h₂ --R₂--> p₂ --H--> ... --Rₜ--> pₜ
\end{verbatim}

\textbf{Avantage} : Élimine les collisions de chaînes !

\textbf{Comparaison Hellman vs Rainbow} :

\begin{center}
\begin{tabular}{|l|c|c|}
\hline
\textbf{Caractéristique} & \textbf{Hellman} & \textbf{Rainbow} \\
\hline
Fonctions réduction & 1 seule ($R$) & $t$ différentes ($R_1 \ldots R_t$) \\
Collisions chaînes & Oui (50\%) & Non (éliminées) \\
Couverture ($m \times t$) & $\sim 0.5 \times m \times t$ & $\sim 0.86 \times m \times t$ \\
Temps recherche & $O(t^2)$ & $O(t^2)$ \\
Efficacité & Moyenne & \textbf{2× meilleure} \\
\hline
\end{tabular}
\end{center}

\textbf{Exemple Concret} :
\begin{itemize}
    \item Espace : alphanumériques 8 chars = $62^8 \approx 2.18 \times 10^{14}$
    \item Hash : MD5 (rapide)
    \item Chaînes : $m = 10^8$ (100 millions)
    \item Longueur : $t = 10^6$ (1 million)
    \item Couverture : $\sim 8.6 \times 10^{13}$ (40\% de l'espace)
    \item \textbf{Espace disque : 1.6 GB seulement !}
\end{itemize}

\begin{importantbox}
\textbf{Défense : Le salage rend Rainbow Tables inutiles}

Avec sel de 128 bits : $2^{128} \approx 3.4 \times 10^{38}$ sels possibles

Espace requis : $2^{128} \times 1.6$ GB $\approx 10^{38}$ exaoctets (totalement infaisable !)

\textbf{Conclusion} : Le salage ($\geq 128$ bits) rend Rainbow Tables complètement inefficaces.
\end{importantbox}

\subsection{Protocoles Challenge-Response}

\textbf{Objectif} : Ne JAMAIS transmettre le mot de passe sur le réseau.

\textbf{Protocole basique (HMAC)} :
\begin{enumerate}
    \item Client $\to$ Server : username
    \item Server $\to$ Client : challenge (nonce aléatoire)
    \item Client $\to$ Server : response = HMAC(password\_key, challenge)
    \item Server vérifie : response $\stackrel{?}{=}$ HMAC(stored\_key, challenge)
\end{enumerate}

\textbf{Avantages} :
\begin{itemize}
    \item Mot de passe jamais transmis
    \item Protection contre replay attack
\end{itemize}

\subsection{Authentification Multi-Facteurs (MFA)}

\textbf{TOTP (Time-based One-Time Password)} :
$$\text{TOTP} = \text{Truncate}(\text{HMAC-SHA1}(K, \lfloor T / 30 \rfloor))$$

Standard : RFC 6238 (Google Authenticator, Authy)

\textbf{FIDO2/WebAuthn} : Standard moderne (passwordless), utilise cryptographie à clé publique, résiste au phishing.

\newpage

%==============================================================================
\section{Sécurité Réseau}
%==============================================================================

\subsection{Attaques DoS/DDoS}

\textbf{SYN Flood} :
\begin{enumerate}
    \item Attaquant $\to$ Server : SYN (IP source forgée)
    \item Server $\to$ (void) : SYN-ACK (va nulle part)
    \item Server alloue ressources et attend ACK qui ne vient jamais
    \item Table de connexions saturée $\to$ Denial of Service
\end{enumerate}

\textbf{Défense : SYN Cookies} :
$$\text{seq\_num} = \text{Hash}(\text{src\_ip}, \text{src\_port}, \text{dst\_ip}, \text{dst\_port}, \text{time}, \text{secret})$$

Ne stocke PAS l'état avant connexion complète.

\textbf{Amplification Attacks} :

\begin{center}
\begin{tabular}{|l|c|c|c|}
\hline
\textbf{Protocole} & \textbf{Requête} & \textbf{Réponse} & \textbf{Facteur} \\
\hline
DNS (ANY) & 60 B & 3000 B & \textbf{50x} \\
NTP (monlist) & 48 B & 468 B & 9.7x \\
Memcached & 15 B & 750 KB & \textbf{51,000x} \\
\hline
\end{tabular}
\end{center}

\subsection{Firewalls}

\textbf{Types} :
\begin{enumerate}
    \item \textbf{Packet Filtering} (stateless) : Filtre IP source/dest, ports, protocole
    \item \textbf{Stateful Firewall} : Suit l'état des connexions TCP
    \item \textbf{Application Layer / WAF} : Inspecte contenu HTTP/HTTPS, détecte SQLi, XSS
\end{enumerate}

\textbf{Principe du moindre privilège} : Tout bloquer par défaut, autoriser explicitement.

\subsection{IDS/IPS (Intrusion Detection/Prevention Systems)}

\textbf{IDS} : Détecte et alerte (passif)

\textbf{IPS} : Détecte et bloque (actif)

\textbf{Types de détection} :
\begin{enumerate}
    \item \textbf{Signature-based} : Compare trafic à signatures d'attaques connues (rapide, vulnérable aux zero-days)
    \item \textbf{Anomaly-based} : Détecte déviations du comportement normal (détecte attaques inconnues, taux élevé de faux positifs)
\end{enumerate}

\textbf{Métriques IDS} :
\begin{itemize}
    \item \textbf{TPR} (True Positive Rate) : Pr[Alerte | Attaque] (sensibilité)
    \item \textbf{FPR} (False Positive Rate) : Pr[Alerte | Normal]
    \item \textbf{PPV} (Positive Predictive Value) : Pr[Attaque | Alerte] = TP / (TP + FP)
\end{itemize}

\subsection{Base-Rate Fallacy et IDS}

\textbf{Le problème} : Un IDS avec 99\% de précision est-il vraiment efficace ?

\subsubsection{Exemple Concret : IDS "99\% précis"}

\textbf{Paramètres} :
\begin{itemize}
    \item TPR = 99\% (détecte 99\% des attaques)
    \item FPR = 1\% (1\% du trafic légitime déclenche alerte)
    \item \textbf{Base rate} : Pr[Attaque] = 0.1\% (0.1\% du trafic est malveillant)
\end{itemize}

\textbf{Théorème de Bayes} :
$$\Pr[\text{Attaque} \mid \text{Alerte}] = \frac{\Pr[\text{Alerte} \mid \text{Attaque}] \times \Pr[\text{Attaque}]}{\Pr[\text{Alerte}]}$$

où :
\begin{align*}
\Pr[\text{Alerte}] &= \Pr[\text{Alerte} \mid \text{Attaque}] \times \Pr[\text{Attaque}] + \Pr[\text{Alerte} \mid \text{Normal}] \times \Pr[\text{Normal}] \\
&= 0.99 \times 0.001 + 0.01 \times 0.999 \\
&= 0.00099 + 0.00999 = 0.01098
\end{align*}

Donc :
$$\Pr[\text{Attaque} \mid \text{Alerte}] = \frac{0.99 \times 0.001}{0.01098} = \frac{0.00099}{0.01098} \approx 0.09 = 9\%$$

\begin{warnbox}
\textbf{Résultat choquant} : Seulement \textbf{9\% des alertes sont vraies} !

$\to$ \textbf{91\% sont des faux positifs} !
\end{warnbox}

\subsubsection{Table de Confusion (100,000 connexions)}

\begin{center}
\begin{tabular}{|l|c|c|c|}
\hline
 & \textbf{Attaque réelle} & \textbf{Trafic normal} & \textbf{Total} \\
\hline
\textbf{Alerte} & 99 (TP) & 999 (FP) & 1,098 \\
\textbf{Pas alerte} & 1 (FN) & 98,901 (TN) & 98,902 \\
\hline
\textbf{Total} & 100 & 99,900 & 100,000 \\
\hline
\end{tabular}
\end{center}

\textbf{Calcul PPV} :
$$\text{PPV} = \frac{\text{TP}}{\text{TP} + \text{FP}} = \frac{99}{99 + 999} = \frac{99}{1{,}098} \approx 9\%$$

\subsubsection{Le Phénomène de Base-Rate Fallacy}

\textbf{Intuition erronée} : "Mon IDS a 99\% de précision, donc si une alerte se déclenche, il y a 99\% de chances que ce soit une attaque."

\textbf{FAUX !} Cette intuition ignore :
\begin{itemize}
    \item Le taux de base des attaques est très faible (0.1\%)
    \item Il y a BEAUCOUP PLUS de trafic légitime que malveillant
    \item Même 1\% de FPR génère énormément de fausses alertes
\end{itemize}

\textbf{Calcul mental rapide} :
\begin{itemize}
    \item 100,000 connexions : 100 attaques, 99,900 normales
    \item FP générés : $99{,}900 \times 1\% = 999$ fausses alertes
    \item TP générés : $100 \times 99\% = 99$ vraies alertes
    \item Ratio FP:TP = 999:99 $\approx$ 10:1
\end{itemize}

\subsubsection{Solutions pour Améliorer le PPV}

\textbf{1. Réduire le FPR} (impact énorme !)

\begin{center}
\begin{tabular}{|c|c|c|}
\hline
\textbf{FPR} & \textbf{Alertes totales} & \textbf{PPV} \\
\hline
1\% & 1,098 & \textbf{9\%} \\
0.5\% & 599 & 16\% \\
0.1\% & 199 & \textbf{50\%} \\
0.01\% & 109 & \textbf{91\%} \\
\hline
\end{tabular}
\end{center}

$\to$ Diviser FPR par 10 améliore PPV de 9\% à 50\% !

\textbf{2. Corrélation d'événements} :
\begin{itemize}
    \item Combiner 2 IDS indépendants (FPR = 1\% chacun)
    \item FPR combiné : $0.01 \times 0.01 = 0.01\%$
    \item PPV passe à $\sim 91\%$ !
\end{itemize}

\textbf{3. Machine Learning et Tuning} : Feature engineering, ensemble methods, anomaly scoring

\textbf{4. Context-Aware Detection} : Historique utilisateur/IP, géolocalisation, reputation scoring

\begin{importantbox}
\textbf{Conclusion} : Le taux de base (base rate) est CRUCIAL pour interpréter les alertes. Toujours calculer PPV, pas seulement TPR. Réduire FPR est plus important qu'augmenter TPR dans de nombreux cas.
\end{importantbox}

\newpage

%==============================================================================
\section{Sûreté Mémoire (Buffer Overflow)}
%==============================================================================

\subsection{Stack Frame x86 32-bit}

\textbf{Layout mémoire} :

\begin{verbatim}
Adresses hautes
+-----------------+ <- EBP + 8
| Arguments       |
+-----------------+ <- EBP + 4
| Return Address  | <- CIBLE de l'attaque !
+-----------------+ <- EBP
| Saved EBP       |
+-----------------+
| Variables loc.  |
+-----------------+
| buffer[N]       | <- Débordement
+-----------------+ <- ESP
Adresses basses
\end{verbatim}

\subsection{Exploitation Buffer Overflow}

\textbf{Mécanisme} :
\begin{enumerate}
    \item Déborder le buffer pour écraser return address
    \item Rediriger vers shellcode injecté
    \item Shellcode s'exécute avec privilèges du programme
\end{enumerate}

\textbf{Payload typique} :
\begin{verbatim}
[NOP sled][Shellcode][Padding][Return Address]
\end{verbatim}

\textbf{Shellcode Linux x86 (execve("/bin/sh"), 23 bytes)} :
\begin{verbatim}
\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e
\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80
\end{verbatim}

\subsection{Défenses Modernes}

\begin{enumerate}
    \item \textbf{Stack Canaries} : Valeur aléatoire placée avant return address, vérifiée avant \texttt{ret}
    \item \textbf{NX bit (DEP)} : Stack non-exécutable (\texttt{gcc -z noexecstack})
    \item \textbf{ASLR} : Randomisation adresses mémoire (stack, heap, libraries)
    \item \textbf{ROP (Return-Oriented Programming)} : Attaque contournant NX en chaînant gadgets existants
\end{enumerate}

\begin{exbox}
\textbf{Compilation sécurisée} :
\begin{verbatim}
gcc -fstack-protector-all -D_FORTIFY_SOURCE=2 \
    -pie -fPIE -Wl,-z,relro,-z,now,-z,noexecstack \
    program.c
\end{verbatim}
\end{exbox}

\newpage

%==============================================================================
\section{Formules et Concepts Clés}
%==============================================================================

\subsection{Cryptographie}

\textbf{Perfect Security} :
$$\Pr[M = m \mid C = c] = \Pr[M = m]$$

\textbf{PRG Advantage} :
$$\text{PRGadv}[A, G] = |\Pr[A(G(s)) = 1] - \Pr[A(r) = 1]|$$

\textbf{HMAC} :
$$\text{HMAC}_k(m) = H\left((k \oplus \text{opad}) \| H((k \oplus \text{ipad}) \| m)\right)$$

\subsection{Authentification}

\textbf{TOTP} :
$$\text{TOTP} = \text{Truncate}(\text{HMAC-SHA1}(K, \lfloor T / 30 \rfloor))$$

\subsection{Sécurité Réseau}

\textbf{Bayes Theorem} :
$$\Pr[A \mid B] = \frac{\Pr[B \mid A] \times \Pr[A]}{\Pr[B]}$$

où :
$$\Pr[B] = \sum_i \Pr[B \mid A_i] \times \Pr[A_i]$$

\textbf{PPV (Positive Predictive Value)} :
$$\text{PPV} = \frac{\text{TP}}{\text{TP} + \text{FP}}$$

%==============================================================================
\section{Checklist Examens}
%==============================================================================

\subsection{Examens Janvier 2024}

\textbf{Q1 : Vrai/Faux (10 points)}
\begin{itemize}
    \item Perfect Security, OTP, théorème de Shannon
    \item PRG sécurisé, indistinguabilité
    \item AES-CBC et IV aléatoire
    \item HMAC et collisions
    \item bcrypt vs SHA-256 pour mots de passe
    \item Firewall stateful et attaques applicatives
    \item Buffer overflow et exécution code arbitraire
    \item ASLR et impossibilité buffer overflow
    \item E2EE et protection MITM
\end{itemize}

\textbf{Q2 : Rainbow Tables (5 points)}
\begin{itemize}
    \item Principe Hellman vs Rainbow
    \item Avantages Rainbow Tables
    \item Impact du salage
\end{itemize}

\textbf{Q3 : Buffer Overflow avec Protection (5 points)}
\begin{itemize}
    \item Dessiner stack frame
    \item Calculer offsets
    \item Contourner canary maison
    \item Améliorations proposées
\end{itemize}

\subsection{Examens Janvier 2025}

\textbf{Q1 : PRG Security (7 points)}
\begin{itemize}
    \item Définition formelle sécurité PRG
    \item Analyse $G(s) = s \| \text{AES}_s(0^{128})$
    \item Proposer PRG insécurisé et prouver
\end{itemize}

\textbf{Q2 : IDS base-rate fallacy (6 points)}
\begin{itemize}
    \item Calcul avec théorème de Bayes
    \item TPR = 99\%, FPR = 1\%, base rate = 0.1\%
    \item Expliquer phénomène base-rate fallacy
\end{itemize}

\textbf{Q3 : Stack Frame (7 points)}
\begin{itemize}
    \item Dessiner stack frame complet
    \item Calculer offset exact
    \item Proposer payload exploitation
    \item Lister vulnérabilités
\end{itemize}

%==============================================================================
\section{Conseils de Révision}
%==============================================================================

\begin{importantbox}
\textbf{Points clés à maîtriser} :

\begin{enumerate}
    \item \textbf{Formules} : Mémoriser Perfect Security, PRG, HMAC, TOTP, Bayes
    \item \textbf{Tableaux} : KDF comparison, AES modes, amplification factors, FPR vs PPV
    \item \textbf{Stack frames} : Savoir calculer offsets (EBP $\pm$ X)
    \item \textbf{Base-rate fallacy} : Toujours calculer PPV avec Bayes, comprendre impact FPR
    \item \textbf{Rainbow tables} : Comprendre Hellman vs Rainbow, impact du salage ($2^{128}$ sels)
    \item \textbf{Défenses} : Connaître limitations de chaque mécanisme (ASLR, NX, canaries)
    \item \textbf{Cryptographie} : Différence perfect vs computational security
    \item \textbf{Authentification} : Pourquoi bcrypt > SHA-256, rôle du sel
\end{enumerate}
\end{importantbox}

\textbf{Méthode de travail} :
\begin{itemize}
    \item Refaire les calculs de Bayes (IDS question)
    \item Dessiner stack frames pour différents scénarios
    \item Expliquer oralement les concepts (rainbow tables, base-rate fallacy)
    \item Comparer les approches (Hellman vs Rainbow, ECB vs CBC vs CTR)
\end{itemize}

\vspace{1cm}

\begin{center}
\textit{"Security is a process, not a product."} \\
— Bruce Schneier
\end{center}

\end{document}

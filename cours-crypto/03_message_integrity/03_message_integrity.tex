\documentclass[11pt,a4paper]{article}

% [Préambule identique]
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{lmodern}
\usepackage{geometry}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{tcolorbox}
\usepackage{enumitem}
\usepackage{algorithm}
\usepackage{algorithmic}

\geometry{margin=2.5cm}

\newtheorem{definition}{Définition}[section]
\newtheorem{theorem}{Théorème}[section]
\newtheorem{example}{Exemple}[section]

\newtcolorbox{defbox}{colback=blue!5!white,colframe=blue!75!black}
\newtcolorbox{warnbox}{colback=red!5!white,colframe=red!75!black}

\newcommand{\MAC}{\textsf{MAC}}
\newcommand{\Tag}{\textsf{Tag}}
\newcommand{\Vrfy}{\textsf{Vrfy}}
\newcommand{\xor}{\oplus}
\newcommand{\bits}{\{0,1\}}

\title{\textbf{Chapitre 3 : Intégrité des Messages\\MAC, Hachage et Authenticated Encryption}}
\author{Cours de Cryptographie}
\date{\today}

\begin{document}

\maketitle
\tableofcontents
\newpage

%=============================================================================
\section{Introduction}
%=============================================================================

\textbf{Problème} : Le chiffrement seul (chapitres 1-2) garantit la \textbf{confidentialité} mais pas l'\textbf{intégrité}. Un attaquant peut modifier les ciphertexts !

\textbf{Objectifs} :
\begin{itemize}
    \item Détecter toute modification des messages
    \item Authentifier la source du message
    \item Combiner confidentialité + intégrité (Authenticated Encryption)
\end{itemize}

\textbf{Outils} :
\begin{enumerate}
    \item Message Authentication Codes (MAC)
    \item Fonctions de hachage résistantes aux collisions
    \item Authenticated Encryption with Associated Data (AEAD)
\end{enumerate}

%=============================================================================
\section{Message Authentication Codes (MAC)}
%=============================================================================

\subsection{Définition}

\begin{defbox}
\textbf{Message Authentication Code (MAC)}

Un MAC est un tuple d'algorithmes $(\Gen, \Tag, \Vrfy)$ :
\begin{itemize}
    \item $\Gen$ : génère une clé secrète $k \xleftarrow{\$} \K$
    \item $\Tag_k(m)$ : produit un tag $t \in \mathcal{T}$ pour le message $m$
    \item $\Vrfy_k(m, t)$ : retourne 1 (valide) ou 0 (invalide)
\end{itemize}

\textbf{Correction} : $\Vrfy_k(m, \Tag_k(m)) = 1$ pour tous $k, m$.
\end{defbox}

\subsection{Modèle de sécurité : UF-CMA}

\textbf{Unforgeability under Chosen Message Attack}

\begin{algorithm}
\caption{Jeu UF-CMA}
\begin{algorithmic}
\STATE Challenger génère $k \xleftarrow{\$} \K$
\STATE $\A$ interroge $\Tag_k(\cdot)$ sur $m_1, \ldots, m_q$ (obtient $t_1, \ldots, t_q$)
\STATE $\A$ produit $(m^*, t^*)$ avec $m^* \notin \{m_1, \ldots, m_q\}$
\STATE $\A$ gagne si $\Vrfy_k(m^*, t^*) = 1$
\end{algorithmic}
\end{algorithm}

\textbf{Sécurité} : $\Pr[\A \text{ gagne}] \leq \epsilon$ négligeable.

\subsection{Constructions}

\subsubsection{CBC-MAC}

\textbf{Principe} : Utiliser un block cipher en mode CBC, ne garder que le dernier bloc comme tag.

\begin{algorithm}
\caption{CBC-MAC}
\begin{algorithmic}
\REQUIRE Message $m = m_1 \| m_2 \| \cdots \| m_\ell$ (chaque $m_i$ de $n$ bits), clé $k$
\STATE $t_0 \gets 0^n$ \hfill // IV = vecteur nul
\FOR{$i = 1$ to $\ell$}
    \STATE $t_i \gets E_k(t_{i-1} \xor m_i)$
\ENDFOR
\RETURN $t_\ell$ (dernier bloc)
\end{algorithmic}
\end{algorithm}

\textbf{Propriétés} :
\begin{itemize}
    \item Déterministe (pas d'IV aléatoire comme en chiffrement)
    \item Sécurisé (UF-CMA) pour messages de \textbf{longueur fixe}
    \item Ne nécessite qu'une seule clé $k$
\end{itemize}

\begin{warnbox}
\textbf{DANGER : CBC-MAC basique est INSÉCURISÉ pour messages de longueur variable !}

\textbf{Attaque} : Si on connaît $t = \text{CBC-MAC}_k(m)$ pour un message $m$ de 1 bloc, alors pour un message $m' = m \| (m \xor t)$ de 2 blocs :
\[
\text{CBC-MAC}_k(m') = E_k(E_k(m) \xor (m \xor t)) = E_k(t \xor m \xor t) = E_k(m) = t
\]

L'attaquant peut forger un tag pour $m'$ sans connaître la clé !
\end{warnbox}

\textbf{Solutions} :

\begin{enumerate}
    \item \textbf{CBC-MAC longueur fixe} : Spécifier $\ell$ dans la définition du schéma. Sécurisé mais inflexible.

    \item \textbf{Encoder la longueur} : Préfixer le message par sa longueur $\ell$. Sécurisé mais nécessite de connaître $\ell$ à l'avance.

    \item \textbf{CMAC (Cipher-based MAC, NIST SP 800-38B)} : Utiliser deux clés dérivées $k_1, k_2$ et traiter le dernier bloc différemment.

    \item \textbf{OMAC (One-Key MAC)} : Variante de CMAC avec une seule clé et dérivation via multiplication dans $\text{GF}(2^n)$.
\end{enumerate}

\textbf{CMAC Construction (standard actuel)} :
\begin{itemize}
    \item Dériver deux sous-clés : $k_1 = E_k(0^n) \cdot x$ et $k_2 = k_1 \cdot x$ dans $\text{GF}(2^n)$
    \item CBC-MAC classique pour les $\ell-1$ premiers blocs
    \item Dernier bloc :
    \begin{itemize}
        \item Si bloc complet : $m_\ell \xor k_1$
        \item Si bloc incomplet : $\text{pad}(m_\ell) \xor k_2$
    \end{itemize}
\end{itemize}

\textbf{Sécurité de CMAC} : UF-CMA sécurisé pour messages de longueur variable (prouvé)

\textbf{Usage} : Standard NIST, utilisé dans AES-CCM

\subsubsection{HMAC (Hash-based MAC)}

\begin{defbox}
\textbf{HMAC Construction}

Soit $H$ une fonction de hachage (ex: SHA-256). On définit :
\[
\text{HMAC}_k(m) = H((k \xor \text{opad}) \| H((k \xor \text{ipad}) \| m))
\]

où :
\begin{itemize}
    \item $\text{ipad} = 0x36$ répété (inner padding)
    \item $\text{opad} = 0x5C$ répété (outer padding)
    \item $k$ est ajusté à la taille de bloc de $H$
\end{itemize}
\end{defbox}

\textbf{Sécurité} : HMAC est UF-CMA sécurisé si $H$ est résistante aux collisions.

\textbf{Standards} : HMAC-SHA256, HMAC-SHA384, HMAC-SHA512

%=============================================================================
\section{Fonctions de hachage cryptographiques}
%=============================================================================

\subsection{Définition et propriétés}

\begin{defbox}
\textbf{Fonction de hachage cryptographique}

$H : \bits^* \to \bits^n$ doit satisfaire :
\begin{enumerate}
    \item \textbf{Résistance aux préimages} : Difficile de trouver $m$ tel que $H(m) = h$ (étant donné $h$)
    \item \textbf{Résistance aux secondes préimages} : Difficile de trouver $m' \neq m$ tel que $H(m') = H(m)$ (étant donné $m$)
    \item \textbf{Résistance aux collisions} : Difficile de trouver $m_1 \neq m_2$ tel que $H(m_1) = H(m_2)$
\end{enumerate}
\end{defbox}

\subsection{Paradoxe des anniversaires}

\textbf{Question} : Combien de personnes faut-il pour que deux aient la même date d'anniversaire avec probabilité $> 50\%$ ?

\textbf{Réponse} : 23 personnes ! (contre-intuitif)

\textbf{Généralisation} : Pour une fonction de hachage $H : \bits^* \to \bits^n$, trouver une collision nécessite $\approx \sqrt{2^n} = 2^{n/2}$ évaluations.

\textbf{Conséquence} : SHA-256 ($n=256$) résiste à $2^{128}$ essais.

\subsection{Construction : Merkle-Damgård}

\textbf{Principe} : Construire une fonction de hachage à longueur variable à partir d'une fonction de compression à longueur fixe.

\subsubsection{Fonction de compression}

\begin{defbox}
\textbf{Fonction de compression}

$h : \bits^n \times \bits^b \to \bits^n$ prend un \textbf{chaining value} de $n$ bits et un \textbf{bloc de message} de $b$ bits, produit un nouveau chaining value de $n$ bits.

\textbf{Exemple} : Pour SHA-256, $n = 256$ bits, $b = 512$ bits.
\end{defbox}

\subsubsection{Construction Merkle-Damgård}

\begin{algorithm}
\caption{Merkle-Damgård Hash}
\begin{algorithmic}
\REQUIRE Message $m$ de longueur arbitraire
\STATE // Étape 1 : Padding
\STATE $m' \gets m \| 1 \| 0^k \| \langle |m| \rangle_{64}$ \hfill // $k$ tel que longueur totale $\equiv 0 \pmod{b}$
\STATE // Étape 2 : Découpage en blocs
\STATE Découper $m'$ en blocs $m_1, m_2, \ldots, m_t$ de $b$ bits chacun
\STATE // Étape 3 : Itération
\STATE $H_0 \gets \text{IV}$ \hfill // Valeur d'initialisation fixée (ex: constantes pour SHA-256)
\FOR{$i = 1$ to $t$}
    \STATE $H_i \gets h(H_{i-1}, m_i)$ \hfill // Fonction de compression
\ENDFOR
\RETURN $H_t$
\end{algorithmic}
\end{algorithm}

\textbf{Composants clés} :

\begin{enumerate}
    \item \textbf{IV (Initialization Vector)} : Constante publique fixée dans le standard (ex: SHA-256 utilise les 32 premiers bits des racines carrées des 8 premiers nombres premiers)

    \item \textbf{Padding} :
    \begin{itemize}
        \item Toujours ajouter au moins 1 bit (le bit '1')
        \item Encoder la longueur du message original en fin (MD-strengthening)
        \item Assure que $\text{pad}(m_1) \neq \text{pad}(m_2)$ si $m_1 \neq m_2$
    \end{itemize}

    \item \textbf{Fonction de compression $h$} : Construction spécifique à chaque algorithme (Davies-Meyer pour SHA-2, éponge pour SHA-3)
\end{enumerate}

\begin{theorem}[Merkle-Damgård]
Si la fonction de compression $h$ est résistante aux collisions, alors la fonction de hachage $H$ construite par Merkle-Damgård est résistante aux collisions.
\end{theorem}

\begin{proof}[Idée de la preuve]
Par contraposée. Supposons qu'on trouve une collision pour $H$ : $H(m) = H(m')$ avec $m \neq m'$.

Soient $m_1, \ldots, m_t$ et $m_1', \ldots, m_{t'}$ les blocs après padding.

Si $t = t'$ et $m_t \neq m_t'$ : alors $h(H_{t-1}, m_t) = h(H_{t-1}', m_{t'}')$ est une collision pour $h$.

Si $t \neq t'$ ou les derniers blocs sont égaux mais les chaining values diffèrent : on remonte itérativement pour trouver une collision pour $h$.

Donc collision sur $H$ $\Rightarrow$ collision sur $h$. Par contraposée : $h$ résistant aux collisions $\Rightarrow$ $H$ résistant aux collisions. \qed
\end{proof}

\subsubsection{Davies-Meyer (utilisé dans SHA-256)}

Une construction populaire de fonction de compression :
\[
h(H_{i-1}, m_i) = E_{m_i}(H_{i-1}) \xor H_{i-1}
\]

où $E_k$ est un block cipher (clé = bloc de message, plaintext = chaining value).

\subsubsection{Limitations de Merkle-Damgård}

\begin{itemize}
    \item \textbf{Length extension attack} : Si on connaît $H(m)$ (mais pas $m$), on peut calculer $H(m \| \text{suffix})$ pour n'importe quel suffix !

    \textbf{Conséquence} : $H(k \| m)$ n'est PAS un MAC sécurisé (où $k$ est une clé secrète)

    \item \textbf{Séquentiel} : Impossible de paralléliser le calcul

    \item \textbf{Pas de résistance aux collisions pour états internes} : Collision sur $H_i$ ne correspond pas nécessairement à collision sur $H(m)$
\end{itemize}

\textbf{Évolution} : SHA-3 utilise la construction \textbf{éponge} (sponge), différente de Merkle-Damgård, qui n'est pas vulnérable aux length extension attacks.

\subsection{Fonctions de hachage modernes}

\begin{center}
\begin{tabular}{|l|c|c|l|}
\hline
Fonction & Sortie & Sécurité & Statut \\
\hline
MD5 & 128 bits & ❌ CASSÉ & Obsolète \\
SHA-1 & 160 bits & ❌ CASSÉ (2017) & Déprécié \\
SHA-256 & 256 bits & ✅ Sécurisé & Standard \\
SHA-3 & Variable & ✅ Sécurisé & Standard (2015) \\
BLAKE2 & Variable & ✅ Sécurisé & Rapide \\
\hline
\end{tabular}
\end{center}

%=============================================================================
\section{Authenticated Encryption}
%=============================================================================

\subsection{Principe}

Combiner chiffrement (confidentialité) et MAC (intégrité/authenticité) en un seul schéma.

\subsection{Compositions naïves}

Trois approches possibles :

\begin{enumerate}
    \item \textbf{Encrypt-and-MAC} : $c = \Enc_k(m)$, $t = \MAC_{k'}(m)$
    \item \textbf{MAC-then-Encrypt} : $t = \MAC_{k'}(m)$, $c = \Enc_k(m \| t)$
    \item \textbf{Encrypt-then-MAC} : $c = \Enc_k(m)$, $t = \MAC_{k'}(c)$
\end{enumerate}

\begin{warnbox}
\textbf{Seul Encrypt-then-MAC est génériquement sécurisé !}

\begin{itemize}
    \item Encrypt-and-MAC : Le tag peut fuiter de l'information sur $m$
    \item MAC-then-Encrypt : Vulnérable aux padding oracle attacks
    \item \textbf{Encrypt-then-MAC} : Prouvé sécurisé (CCA-secure)
\end{itemize}
\end{warnbox}

\subsection{AEAD : Authenticated Encryption with Associated Data}

\begin{defbox}
\textbf{AEAD}

\textbf{API} :
\begin{itemize}
    \item $\Enc_k(m, \text{AD})$ : Chiffre $m$, authentifie $m$ et les données associées AD
    \item $\Dec_k(c, \text{AD})$ : Déchiffre et vérifie, retourne $m$ ou $\perp$ (erreur)
\end{itemize}

\textbf{Associated Data (AD)} : Données non chiffrées mais authentifiées (ex: en-têtes réseau)
\end{defbox}

\subsection{Standards AEAD}

\subsubsection{AES-GCM (Galois/Counter Mode)}

\textbf{Le plus utilisé en pratique}
\begin{itemize}
    \item Chiffrement : AES en mode CTR
    \item Authentification : GMAC (basé sur multiplication dans $\text{GF}(2^{128})$)
    \item Très rapide avec accélération matérielle (instructions AES-NI, PCLMULQDQ)
    \item Utilisé dans TLS 1.3, IPsec, SSH
\end{itemize}

\subsubsection{ChaCha20-Poly1305}

\textbf{Alternative moderne}
\begin{itemize}
    \item Chiffrement : ChaCha20 stream cipher
    \item Authentification : Poly1305 MAC
    \item Plus rapide qu'AES-GCM sans accélération matérielle
    \item Utilisé dans TLS 1.3, WireGuard VPN
\end{itemize}

\subsubsection{AES-CCM (Counter with CBC-MAC)}

\textbf{Construction} :
\begin{itemize}
    \item Authentification : CBC-MAC (CMAC)
    \item Chiffrement : AES en mode CTR
    \item Composition : MAC-then-Encrypt (calcule MAC du plaintext, puis chiffre tout)
\end{itemize}

\textbf{Propriétés} :
\begin{itemize}
    \item Prouvé sécurisé (CCA-secure)
    \item Nécessite deux passes sur les données (MAC puis chiffrement) $\Rightarrow$ plus lent que GCM
    \item Taille de tag configurable (4-16 octets)
\end{itemize}

\textbf{Usage} : WPA2 (Wi-Fi), Bluetooth LE, IEEE 802.15.4 (Zigbee), IPsec

\subsubsection{AES-OCB (Offset Codebook Mode)}

\textbf{Construction} : Mode AEAD avec une seule passe (chiffrement et authentification simultanés).

\textbf{Principe} :
\begin{itemize}
    \item Utilise des offsets pseudo-aléatoires dérivés du nonce
    \item Chaque bloc : $c_i = E_k(m_i \xor \text{Offset}_i) \xor \text{Offset}_i$
    \item Tag : XOR de tous les états internes
\end{itemize}

\textbf{Avantages} :
\begin{itemize}
    \item \textbf{Très rapide} : Une seule passe, parallélisable
    \item Optimal en nombre d'appels à $E_k$ (approche le minimum théorique)
    \item Sécurité prouvée
\end{itemize}

\textbf{Inconvénient} :
\begin{itemize}
    \item \textbf{Brevets} (jusqu'en 2021) $\Rightarrow$ adoption limitée
    \item Licence gratuite pour logiciels open-source depuis 2013
\end{itemize}

\textbf{Usage} : Rare en pratique (à cause de l'historique de brevets), mais techniquement supérieur

\subsubsection{ASCON}

\textbf{Contexte} : Vainqueur de la compétition CAESAR (2014-2019) pour AEAD lightweight.

\textbf{Construction} :
\begin{itemize}
    \item Basé sur la construction \textbf{éponge} (comme SHA-3)
    \item Permutation cryptographique : 320 bits d'état, 12 rounds
    \item Très efficace en hardware (petite surface de silicium)
\end{itemize}

\textbf{Variantes} :
\begin{itemize}
    \item \textbf{ASCON-128} : Clé 128 bits, nonce 128 bits, tag 128 bits
    \item \textbf{ASCON-128a} : Optimisé pour vitesse (8 rounds au lieu de 12)
    \item \textbf{ASCON-80pq} : Clé 160 bits (résistance quantique accrue)
\end{itemize}

\textbf{Propriétés} :
\begin{itemize}
    \item Conçu pour IoT, RFID, systèmes embarqués
    \item Sécurité prouvée dans le modèle standard
    \item Résistant aux side-channel attacks (design simple, sans lookups)
    \item Standardisé par NIST (2023) pour lightweight cryptography
\end{itemize}

\textbf{Performance} :
\begin{itemize}
    \item Hardware : $\sim$3000 GE (gate equivalents) - très compact
    \item Software : Compétitif avec ChaCha20-Poly1305 sur microcontrôleurs
\end{itemize}

\textbf{Usage} : Futur standard pour IoT et systèmes embarqués contraints

%=============================================================================
\section{Attaques pratiques}
%=============================================================================

\subsection{Padding Oracle Attack}

\textbf{Scénario} : CBC + MAC-then-Encrypt avec messages d'erreur différents pour "padding invalide" vs "MAC invalide".

\textbf{Résultat} : L'attaquant peut déchiffrer complètement sans connaître la clé !

\textbf{Exemples historiques} :
\begin{itemize}
    \item ASP.NET (2010)
    \item OpenSSL (2003)
    \item Variantes : POODLE (SSL 3.0), Lucky 13 (TLS)
\end{itemize}

\subsection{Nonce reuse

 dans GCM}

\textbf{Catastrophe} : Réutiliser un nonce en AES-GCM permet de :
\begin{itemize}
    \item Retrouver la clé d'authentification
    \item Forger des tags arbitraires
    \item Casser complètement la confidentialité
\end{itemize}

\textbf{Moralité} : Les nonces doivent être STRICTEMENT uniques !

%=============================================================================
\section{Notebooks pratiques}
%=============================================================================

\begin{itemize}
    \item \texttt{03_demo_mac.ipynb} : HMAC-SHA256
    \item \texttt{03_demo_hash_collisions.ipynb} : Paradoxe des anniversaires, attaques sur MD5
    \item \texttt{03_demo_aead.ipynb} : AES-GCM et ChaCha20-Poly1305
    \item \texttt{03_exercices.ipynb} : Exercices guidés
\end{itemize}

%=============================================================================
\section{Conclusion}
%=============================================================================

\textbf{Points clés} :
\begin{itemize}
    \item Chiffrement seul NE SUFFIT PAS : il faut aussi l'intégrité
    \item MAC : authentification avec clé partagée (HMAC standard)
    \item Hash : empreintes, résistance aux collisions (SHA-256, SHA-3)
    \item AEAD : combinaison sécurisée (AES-GCM, ChaCha20-Poly1305)
    \item Encrypt-then-MAC : seule composition générique sûre
    \item Nonce management : critique pour la sécurité
\end{itemize}

Le chapitre suivant introduira la \textbf{cryptographie à clé publique}, qui résout le problème de la distribution des clés.

\end{document}

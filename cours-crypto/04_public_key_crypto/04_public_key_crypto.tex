\documentclass[11pt,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{lmodern,geometry,amsmath,amssymb,amsthm,hyperref,tcolorbox,enumitem}

\geometry{margin=2.5cm}
\newtheorem{definition}{Définition}[section]
\newtheorem{theorem}{Théorème}[section]
\newtcolorbox{defbox}{colback=blue!5!white,colframe=blue!75!black}

\title{\textbf{Chapitre 4 : Cryptographie à Clé Publique\\Diffie-Hellman, RSA, ElGamal}}
\author{Cours de Cryptographie}
\date{\today}

\begin{document}
\maketitle
\tableofcontents
\newpage

%=============================================================================
\section{Introduction : Le problème de la distribution des clés}
%=============================================================================

\textbf{Problème fondamental} : La cryptographie symétrique nécessite une clé partagée secrète. Comment Alice et Bob établissent-ils une clé commune sans canal sécurisé préalable ?

\textbf{Solution révolutionnaire (1976)} : Diffie et Hellman inventent la cryptographie à clé publique.

\textbf{Paradigme} :
\begin{itemize}
    \item Chaque utilisateur a une paire $(pk, sk)$ : clé publique + clé secrète
    \item $pk$ est publique (annuaire)
    \item $sk$ est gardée secrète
    \item Chiffrement avec $pk$, déchiffrement avec $sk$
\end{itemize}

%=============================================================================
\section{Fondations mathématiques}
%=============================================================================

\subsection{Groupes cycliques}

\begin{defbox}
\textbf{Groupe cyclique}

Un groupe $(G, \cdot)$ d'ordre $q$ est cyclique s'il existe un générateur $g$ tel que :
\[
G = \{g^0, g^1, g^2, \ldots, g^{q-1}\}
\]
\end{defbox}

\textbf{Exemples} :
\begin{itemize}
    \item $(\mathbb{Z}_p^*, \cdot)$ : entiers modulo $p$ premier (ordre $p-1$)
    \item Courbes elliptiques sur corps finis
\end{itemize}

\subsection{Problème du logarithme discret (DLP)}

\begin{defbox}
\textbf{Discrete Logarithm Problem (DLP)}

\textbf{Entrée} : $G, g, h$ où $h \in G$

\textbf{Problème} : Trouver $x$ tel que $g^x = h$

\textbf{Hypothèse} : Aucun algorithme efficace ne résout DLP pour des groupes bien choisis.
\end{defbox}

\textbf{Groupes sécurisés} :
\begin{itemize}
    \item $\mathbb{Z}_p^*$ avec $p$ premier de 2048-4096 bits
    \item Courbes elliptiques (Curve25519, secp256k1) avec 256 bits
\end{itemize}

\subsection{Problème Diffie-Hellman (CDH, DDH)}

Le protocole Diffie-Hellman repose sur deux hypothèses de difficulté distinctes.

\subsubsection{Computational Diffie-Hellman (CDH)}

\begin{defbox}
\textbf{CDH Problem}

\textbf{Entrée} : $G, g, g^a, g^b$ où $a, b \xleftarrow{\$} \mathbb{Z}_q$

\textbf{Problème} : Calculer $g^{ab}$

\textbf{Hypothèse CDH} : Aucun algorithme efficace ne peut résoudre CDH avec probabilité non-négligeable.
\end{defbox}

\textbf{Relation avec DLP} : Si on peut résoudre DLP (trouver $a$ depuis $g^a$), on peut résoudre CDH. Donc : $\text{DLP} \leq \text{CDH}$ (DLP au moins aussi difficile).

\textbf{Usage} : CDH suffit pour la sécurité passive (eavesdropping) de DH.

\subsubsection{Decisional Diffie-Hellman (DDH)}

\begin{defbox}
\textbf{DDH Problem}

\textbf{Jeu} : Distinguer les deux distributions suivantes :
\begin{itemize}
    \item \textbf{Distribution réelle} : $(g, g^a, g^b, g^{ab})$ où $a, b \xleftarrow{\$} \mathbb{Z}_q$
    \item \textbf{Distribution aléatoire} : $(g, g^a, g^b, g^c)$ où $a, b, c \xleftarrow{\$} \mathbb{Z}_q$ (indépendants)
\end{itemize}

\textbf{Hypothèse DDH} : Aucun algorithme efficace ne peut distinguer ces deux distributions avec avantage non-négligeable.
\end{defbox}

\textbf{Formellement} : Pour tout adversaire $\mathcal{A}$ efficace,
\[
\left| \Pr[\mathcal{A}(g, g^a, g^b, g^{ab}) = 1] - \Pr[\mathcal{A}(g, g^a, g^b, g^c) = 1] \right| \leq \epsilon
\]
où $\epsilon$ est négligeable.

\textbf{Relation entre hypothèses} :
\[
\text{DLP} \Rightarrow \text{CDH} \Rightarrow \text{DDH}
\]

\begin{itemize}
    \item Si on résout DLP, on résout CDH
    \item Si on résout CDH, on résout DDH (tester si $Z = g^{ab}$ en calculant $g^{ab}$)
    \item \textbf{Réciproques inconnues} : On ne sait pas si CDH $\Rightarrow$ DLP ou DDH $\Rightarrow$ CDH
\end{itemize}

\textbf{Importance de DDH} : Nécessaire pour prouver la sécurité CPA de ElGamal et de Diffie-Hellman key exchange.

\subsubsection{Groupes où DDH est facile}

\begin{warnbox}
\textbf{Attention : DDH ne tient PAS dans tous les groupes !}

\textbf{Exemple} : $\mathbb{Z}_p^*$ avec $p$ premier

DDH est facile via le \textbf{symbole de Legendre} : Pour $p$ premier impair, on peut tester si un élément est un carré modulo $p$ en temps polynomial.

\textbf{Attaque} : Si $g$ est un générateur de $\mathbb{Z}_p^*$, alors :
\begin{itemize}
    \item $g^{ab}$ est un carré si et seulement si $ab$ est pair
    \item $g^c$ est un carré avec probabilité 1/2 (si $c$ aléatoire)
\end{itemize}

Donc on peut distinguer $(g^a, g^b, g^{ab})$ de $(g^a, g^b, g^c)$ avec probabilité $\approx$ 3/4.

\textbf{Solution} : Travailler dans un sous-groupe d'ordre premier $q$ de $\mathbb{Z}_p^*$ (avec $p = 2q+1$, nombre premier de Sophie Germain).
\end{warnbox}

\textbf{Groupes sûrs pour DDH} :
\begin{itemize}
    \item Sous-groupes premiers de $\mathbb{Z}_p^*$ (avec $p$ choisi correctement)
    \item Courbes elliptiques sur corps finis (Curve25519, NIST P-256, etc.)
\end{itemize}

%=============================================================================
\section{Diffie-Hellman Key Exchange}
%=============================================================================

\subsection{Protocole}

\begin{algorithm}
\caption{Diffie-Hellman}
\begin{algorithmic}
\STATE \textbf{Paramètres publics} : Groupe $G$ d'ordre $q$, générateur $g$
\STATE \textbf{Alice} : Choisit $a \xleftarrow{\$} \mathbb{Z}_q$, calcule $A = g^a$, envoie $A$
\STATE \textbf{Bob} : Choisit $b \xleftarrow{\$} \mathbb{Z}_q$, calcule $B = g^b$, envoie $B$
\STATE \textbf{Alice} : Calcule $K = B^a = g^{ab}$
\STATE \textbf{Bob} : Calcule $K = A^b = g^{ab}$
\STATE \textbf{Clé partagée} : $K = g^{ab}$
\end{algorithmic}
\end{algorithm}

\textbf{Sécurité} : Basée sur l'hypothèse DDH (Decisional Diffie-Hellman)

\subsection{Attaque Man-in-the-Middle}

\textbf{Problème} : DH seul n'authentifie pas les participants !

\textbf{Attaque} :
\begin{itemize}
    \item Eve intercepte $A = g^a$ d'Alice
    \item Eve envoie $E = g^e$ à Bob (se faisant passer pour Alice)
    \item Eve partage $K_1 = g^{ae}$ avec Alice et $K_2 = g^{eb}$ avec Bob
    \item Eve déchiffre et rechiffre tous les messages
\end{itemize}

\textbf{Solution} : Authenticated DH (avec signatures ou certificats)

%=============================================================================
\section{Chiffrement à clé publique}
%=============================================================================

\subsection{Définition}

\begin{defbox}
\textbf{Public Key Encryption}

\textbf{Algorithmes} :
\begin{itemize}
    \item $\textsf{Gen}() \to (pk, sk)$ : Génération de paire de clés
    \item $\textsf{Enc}(pk, m) \to c$ : Chiffrement avec clé publique
    \item $\textsf{Dec}(sk, c) \to m$ : Déchiffrement avec clé secrète
\end{itemize}

\textbf{Correction} : $\textsf{Dec}(sk, \textsf{Enc}(pk, m)) = m$
\end{defbox}

\subsection{Sécurité CPA pour chiffrement asymétrique}

\textbf{Différence avec symétrique} : L'adversaire a accès à $pk$ et peut donc chiffrer lui-même !

\textbf{Jeu IND-CPA} : Similaire au cas symétrique mais $\mathcal{A}$ connaît $pk$.

%=============================================================================
\section{Chiffrement ElGamal}
%=============================================================================

\subsection{Construction}

\begin{defbox}
\textbf{ElGamal Encryption}

\textbf{Paramètres} : Groupe $G$ d'ordre $q$, générateur $g$

\textbf{Gen} :
\begin{itemize}
    \item Choisir $x \xleftarrow{\$} \mathbb{Z}_q$
    \item $pk = g^x$, $sk = x$
\end{itemize}

\textbf{Enc}$(pk, m \in G)$ :
\begin{itemize}
    \item Choisir $r \xleftarrow{\$} \mathbb{Z}_q$
    \item $c_1 = g^r$, $c_2 = m \cdot (pk)^r = m \cdot g^{xr}$
    \item Retourner $(c_1, c_2)$
\end{itemize}

\textbf{Dec}$(sk, (c_1, c_2))$ :
\begin{itemize}
    \item Calculer $s = c_1^{sk} = g^{rx}$
    \item Retourner $m = c_2 / s = (m \cdot g^{xr}) / g^{xr}$
\end{itemize}
\end{defbox}

\textbf{Sécurité} : IND-CPA sous hypothèse DDH

\textbf{Limitation} : Chiffre seulement des éléments de $G$ (pas directement des bitstrings)

%=============================================================================
\section{RSA}
%=============================================================================

\subsection{Arithmétique modulaire}

\textbf{Prérequis} :
\begin{itemize}
    \item Théorème d'Euler : $a^{\phi(n)} \equiv 1 \pmod{n}$
    \item Si $n = pq$ (produit de deux premiers), $\phi(n) = (p-1)(q-1)$
    \item Identité de Bézout, algorithme d'Euclide étendu
\end{itemize}

\subsection{Chiffrement RSA (textbook - INSÉCURISÉ)}

\begin{defbox}
\textbf{RSA Textbook (ne PAS utiliser !)}

\textbf{Gen} :
\begin{itemize}
    \item Choisir deux grands premiers $p, q$ (ex: 1024 bits chacun)
    \item $n = pq$, $\phi(n) = (p-1)(q-1)$
    \item Choisir $e$ tel que $\gcd(e, \phi(n)) = 1$ (souvent $e = 65537$)
    \item Calculer $d = e^{-1} \bmod \phi(n)$
    \item $pk = (n, e)$, $sk = (n, d)$
\end{itemize}

\textbf{Enc}$(pk, m)$ : $c = m^e \bmod n$

\textbf{Dec}$(sk, c)$ : $m = c^d \bmod n$

\textbf{Correction} : $c^d = (m^e)^d = m^{ed} = m^{1 + k\phi(n)} = m \cdot (m^{\phi(n)})^k = m \pmod{n}$
\end{defbox}

\textbf{AVERTISSEMENT} : RSA textbook est \textbf{déterministe} donc PAS CPA-sécurisé !

\subsection{RSA-OAEP (sécurisé)}

\textbf{Optimal Asymmetric Encryption Padding} (Bellare-Rogaway 1994)

\textbf{Principe} : Ajouter du padding randomisé avant chiffrement RSA pour obtenir la sécurité CPA.

\subsubsection{Construction OAEP}

\textbf{Paramètres} :
\begin{itemize}
    \item $k$ : taille du modulus RSA (en bits, ex: 2048)
    \item $k_0$ : taille du paramètre aléatoire (ex: 256 bits)
    \item $k_1$ : taille de la redondance (ex: 128 bits)
    \item $G : \{0,1\}^{k_0} \to \{0,1\}^{n-k_0}$ : fonction de hachage (oracle aléatoire)
    \item $H : \{0,1\}^{n-k_0} \to \{0,1\}^{k_0}$ : fonction de hachage (oracle aléatoire)
    \item $n = k - k_1$ : longueur du bloc OAEP
\end{itemize}

\textbf{Algorithme OAEP-Encode}$(m)$ :
\begin{enumerate}
    \item Choisir $r \xleftarrow{\$} \{0,1\}^{k_0}$ (randomness)
    \item Calculer $s = (m \| 0^{k_1}) \oplus G(r)$ (masquer le message)
    \item Calculer $t = r \oplus H(s)$ (masquer la randomness)
    \item Retourner $s \| t$
\end{enumerate}

\textbf{Chiffrement RSA-OAEP}$(pk, m)$ :
\begin{enumerate}
    \item $\hat{m} \gets \text{OAEP-Encode}(m)$
    \item $c \gets (\hat{m})^e \bmod n$ (RSA textbook sur le bloc paddé)
    \item Retourner $c$
\end{enumerate}

\textbf{Déchiffrement RSA-OAEP}$(sk, c)$ :
\begin{enumerate}
    \item $\hat{m} \gets c^d \bmod n$ (RSA textbook)
    \item Parser $\hat{m} = s \| t$ (découper en deux parties)
    \item $r \gets t \oplus H(s)$ (retrouver randomness)
    \item $m \| \text{pad} \gets s \oplus G(r)$ (retrouver message)
    \item Vérifier que $\text{pad} = 0^{k_1}$ (sinon retourner $\perp$)
    \item Retourner $m$
\end{enumerate}

\subsubsection{Propriétés de sécurité}

\begin{theorem}[Bellare-Rogaway 1994]
Si RSA est une permutation à sens unique (OWF) et $G, H$ sont des oracles aléatoires, alors RSA-OAEP est IND-CPA sécurisé.
\end{theorem}

\textbf{Modèle de l'oracle aléatoire} : Hypothèse forte qui modélise les fonctions de hachage comme des fonctions vraiment aléatoires. Preuve ne tient pas dans le modèle standard, mais pratique acceptable.

\textbf{Intuition de la sécurité} :
\begin{itemize}
    \item La randomness $r$ assure que le chiffrement est \textbf{probabiliste} (même message $\Rightarrow$ ciphertexts différents)
    \item Le double masquage (Feistel network) assure que même si on connaît $m$, on ne peut pas prédire $\hat{m}$ sans connaître $r$
    \item La redondance $0^{k_1}$ empêche les manipulations du ciphertext (non-malléabilité partielle)
\end{itemize}

\subsubsection{Standards et implémentation}

\textbf{PKCS\#1 v2.2} (RFC 8017) spécifie RSA-OAEP avec :
\begin{itemize}
    \item $G$ et $H$ basés sur MGF1 (Mask Generation Function) avec SHA-256 ou SHA-512
    \item Label optionnel $L$ (souvent vide) pour lier le chiffrement à un contexte
    \item Tailles recommandées : $k_0 = 256$ bits (taille de SHA-256), $k_1 = 256$ bits
\end{itemize}

\textbf{Taille maximale du message} : Pour RSA-2048 avec SHA-256,
\[
|m|_{\max} = k - 2k_0 - k_1 - 8 = 2048 - 2 \cdot 256 - 256 - 8 = 1272 \text{ bits} = 159 \text{ octets}
\]

\textbf{Usage pratique} : Pour chiffrer des messages longs, utiliser \textbf{chiffrement hybride} :
\begin{enumerate}
    \item Générer clé symétrique aléatoire $k_{\text{AES}}$
    \item Chiffrer message avec AES-GCM : $c_{\text{sym}} = \text{AES-GCM}_{k_{\text{AES}}}(m)$
    \item Chiffrer clé avec RSA-OAEP : $c_{\text{key}} = \text{RSA-OAEP}(pk, k_{\text{AES}})$
    \item Transmettre $(c_{\text{key}}, c_{\text{sym}})$
\end{enumerate}

\textbf{Alternatives modernes} : ECIES (Elliptic Curve Integrated Encryption Scheme) plus efficace que RSA-OAEP

%=============================================================================
\section{Signatures numériques}
%=============================================================================

\subsection{Définition}

\begin{defbox}
\textbf{Digital Signature}

\textbf{Algorithmes} :
\begin{itemize}
    \item $\textsf{Gen}() \to (pk, sk)$
    \item $\textsf{Sign}(sk, m) \to \sigma$ : Signature
    \item $\textsf{Vrfy}(pk, m, \sigma) \to \{0,1\}$ : Vérification
\end{itemize}
\end{defbox}

\textbf{Sécurité} : UF-CMA (Unforgeability under Chosen Message Attack)

\subsection{RSA Signatures (avec hachage)}

\textbf{Sign}$(sk, m)$ : $\sigma = H(m)^d \bmod n$

\textbf{Vrfy}$(pk, m, \sigma)$ : Vérifier $\sigma^e \stackrel{?}{=} H(m) \pmod{n}$

\subsection{DSA (Digital Signature Algorithm)}

\textbf{Standard NIST} (FIPS 186) basé sur le logarithme discret.

\subsubsection{Construction DSA}

\textbf{Paramètres globaux} :
\begin{itemize}
    \item $p$ : grand nombre premier (2048 ou 3072 bits)
    \item $q$ : nombre premier divisant $p-1$ (256 bits typiquement)
    \item $g$ : générateur d'un sous-groupe d'ordre $q$ dans $\mathbb{Z}_p^*$
    \item $H$ : fonction de hachage (SHA-256)
\end{itemize}

\textbf{Gen}$(1^\lambda)$ :
\begin{itemize}
    \item Choisir $x \xleftarrow{\$} \mathbb{Z}_q$
    \item Calculer $y = g^x \bmod p$
    \item $pk = y$, $sk = x$
\end{itemize}

\textbf{Sign}$(sk, m)$ :
\begin{enumerate}
    \item Choisir $k \xleftarrow{\$} \mathbb{Z}_q^*$ (nonce, DOIT être aléatoire et unique !)
    \item Calculer $r = (g^k \bmod p) \bmod q$
    \item Calculer $s = k^{-1} \cdot (H(m) + x \cdot r) \bmod q$
    \item Retourner $\sigma = (r, s)$
\end{enumerate}

\textbf{Vrfy}$(pk, m, \sigma)$ :
\begin{enumerate}
    \item Parser $\sigma = (r, s)$
    \item Vérifier $0 < r < q$ et $0 < s < q$ (sinon rejeter)
    \item Calculer $w = s^{-1} \bmod q$
    \item Calculer $u_1 = H(m) \cdot w \bmod q$ et $u_2 = r \cdot w \bmod q$
    \item Calculer $v = (g^{u_1} \cdot y^{u_2} \bmod p) \bmod q$
    \item Accepter si et seulement si $v = r$
\end{enumerate}

\textbf{Correction} : Vérifier que
\[
v = (g^{H(m) \cdot w} \cdot g^{xr \cdot w} \bmod p) \bmod q = (g^{k} \bmod p) \bmod q = r
\]
car $w = s^{-1} = k \cdot (H(m) + xr)^{-1}$.

\begin{warnbox}
\textbf{CRITIQUE : Gestion du nonce $k$}

Le nonce $k$ doit être :
\begin{itemize}
    \item \textbf{Vraiment aléatoire} (pas pseudo-aléatoire prévisible)
    \item \textbf{Unique} pour chaque signature
    \item \textbf{Secret} (jamais révélé)
\end{itemize}

\textbf{Attaque si nonce réutilisé} : Si deux signatures $(r_1, s_1)$ et $(r_2, s_2)$ utilisent le même $k$ :
\begin{itemize}
    \item $r_1 = r_2$ (même $g^k$)
    \item De $s_1 - s_2 = k^{-1}(H(m_1) - H(m_2))$, on retrouve $k$
    \item De $s_1 = k^{-1}(H(m_1) + xr_1)$, on retrouve la clé secrète $x$ !
\end{itemize}

\textbf{Cas réels} : PlayStation 3 (2010), Android Bitcoin wallets (2013).
\end{warnbox}

\subsubsection{ECDSA (Elliptic Curve DSA)}

\textbf{Variante de DSA} sur courbes elliptiques. Même algorithme mais :
\begin{itemize}
    \item Groupe : Points d'une courbe elliptique $E(\mathbb{F}_p)$ d'ordre premier $q$
    \item Générateur : Point de base $G$ sur la courbe
    \item Clé publique : $Y = x \cdot G$ (multiplication scalaire)
    \item Signature : Même formule $(r, s)$ mais avec opérations sur courbe
\end{itemize}

\textbf{Avantages} :
\begin{itemize}
    \item Clés plus courtes : 256 bits (ECDSA) $\approx$ 3072 bits (DSA)
    \item Plus rapide (génération et vérification)
    \item Même niveau de sécurité avec moins de ressources
\end{itemize}

\textbf{Courbes standard} :
\begin{itemize}
    \item \textbf{NIST P-256, P-384, P-521} : Standards FIPS, utilisés dans TLS
    \item \textbf{secp256k1} : Utilisée dans Bitcoin, Ethereum
    \item \textbf{Curve25519} : Moderne, résistante aux side-channels (mais pour ECDH, pas signatures)
\end{itemize}

\textbf{Usage} : TLS (certificats), Bitcoin (transactions), SSH, Git (commits signés)

\subsection{EdDSA (moderne)}

\textbf{Ed25519} : Standard moderne, très rapide, résistant aux side-channels

%=============================================================================
\section{Courbes elliptiques}
%=============================================================================

\subsection{Principe}

\textbf{Groupe} : Points d'une courbe elliptique $y^2 = x^3 + ax + b$ sur un corps fini

\textbf{Avantages} :
\begin{itemize}
    \item Clés plus courtes (256 bits ECC $\approx$ 3072 bits RSA)
    \item Opérations plus rapides
    \item Meilleure résistance aux attaques quantiques (Grover seulement, pas Shor pour log discret)
\end{itemize}

\textbf{Courbes standard} :
\begin{itemize}
    \item Curve25519 (X25519 key exchange, Ed25519 signatures)
    \item secp256k1 (Bitcoin, Ethereum)
    \item NIST P-256, P-384, P-521
\end{itemize}

%=============================================================================
\section{Notebooks pratiques}
%=============================================================================

\begin{itemize}
    \item \texttt{04_demo_diffie_hellman.ipynb} : Échange de clés DH
    \item \texttt{04_demo_elgamal.ipynb} : Chiffrement ElGamal
    \item \texttt{04_demo_rsa.ipynb} : RSA (chiffrement OAEP + signatures)
    \item \texttt{04_demo_ecdsa.ipynb} : Courbes elliptiques (ECDH, ECDSA, Ed25519)
    \item \texttt{04_exercices.ipynb} : Exercices guidés
\end{itemize}

%=============================================================================
\section{Conclusion}
%=============================================================================

\textbf{Points clés} :
\begin{itemize}
    \item Cryptographie à clé publique résout la distribution des clés
    \item Basée sur problèmes difficiles (DLP, factorisation)
    \item Diffie-Hellman : échange de clés
    \item ElGamal, RSA : chiffrement asymétrique (avec padding !)
    \item DSA, RSA-PSS, EdDSA : signatures numériques
    \item Courbes elliptiques : efficaces et modernes
\end{itemize}

Le chapitre suivant explore les applications à la \textbf{communication anonyme} (Tor, mixnets).

\end{document}
